{"version":3,"file":"featbit-js-client-sdk.js","mappings":"CAAA,SAA2CA,EAAMC,GAChD,GAAsB,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,SACb,GAAqB,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,OACP,CACJ,IAAIK,EAAIL,IACR,IAAI,IAAIM,KAAKD,GAAuB,iBAAZJ,QAAuBA,QAAUF,GAAMO,GAAKD,EAAEC,EACvE,CACA,CATD,CASGC,MAAM,I,2MCNT,gBACA,aAOA,UACA,UAEA,SACA,UACA,SAEA,aACA,UAWMC,EAA6C,CACjDC,cAAe,EAAAC,eAAeC,OAC9BC,OAAQ,EAAAF,eAAeG,OACvBC,WAAY,EAAAJ,eAAeG,OAC3BE,aAAc,EAAAL,eAAeG,OAC7BG,UAAW,EAAAN,eAAeG,OAC1BI,sBAAuB,EAAAP,eAAeC,OACtCO,OAAQ,EAAAR,eAAeS,OACvBC,MAAO,EAAAV,eAAeW,gBACtBC,iBAAkB,EAAAZ,eAAeW,gBACjCE,cAAe,EAAAb,eAAeC,OAC9Ba,iBAAkB,EAAAd,eAAeC,OACjCc,gBAAiB,EAAAf,eAAeC,OAChCe,QAAS,EAAAhB,eAAeiB,QACxBC,aAAc,EAAAlB,eAAeG,OAC7BgB,UAAW,EAAAnB,eAAeoB,UAC1BC,KAAM,EAAArB,eAAesB,MAMV,EAAAC,cAAmC,CAC9CxB,cAAe,IACfG,OAAQ,GACRE,WAAY,GACZC,aAAc,GACdC,UAAW,GACXY,aAAc,EAAAM,iBAAiBC,UAC/BC,YAAY,EACZnB,sBAAuB,KACvBM,cAAe,IACfC,iBAAkB,IAClBC,gBAAiB,IACjBC,SAAS,EACTN,MAAQiB,GAAsB,IAAI,UAAkBA,GACpDR,eAAWS,EACXP,UAAMO,GAkER,gBAuCE,WAAAC,CAAYF,EAAoB,CAAC,G,QAdjB,KAAAG,kBAAwC,IAAI,EAAAC,sBAiB1DJ,EAAUA,GAAW,CAAC,EAEtB9B,KAAKW,OAASmB,EAAQnB,OAEtB,MAAM,OAACwB,EAAM,iBAAEC,GA7GnB,SAA+BN,GAI7B,IAAIK,EAAmB,GACvB,MAAMC,EAAgB,iBAA0B,EAAAV,eAkChD,OAjCAd,OAAOyB,KAAKP,GAASQ,SAASC,I,MAG5B,MAAMC,EAAeV,EAA2BS,GAC1CE,EAAYxC,EAAYsC,GAC9B,GAAIE,EACF,GAAKA,EAAUC,GAAGF,GAqBhBJ,EAAiBG,GAAcC,OApB/B,GAA4B,YAAxBC,EAAUE,UACZR,EAAOS,KAAK,UAAeC,uBAAuBN,SAAmBC,IACrEJ,EAAiBG,KAAgBC,OAC5B,GACLC,aAAqB,EAAAK,mBACrB,EAAA3C,eAAeC,OAAOsC,GAAGF,GACzB,CACA,MAAM,IAACO,GAAON,EACdN,EAAOS,KAAK,UAAeI,mBAAmBT,EAAYC,EAAaO,IACvEX,EAAiBG,GAAcQ,C,MACtBN,aAAqB,EAAAQ,eAC9Bd,EAAS,IAAIA,KAAWM,EAAUS,UAClCd,EAAiBG,GAAc,EAAAb,cAAca,KAE7CJ,EAAOS,KACL,UAAeO,gBAAgBZ,EAAYE,EAAUE,iBAAkBH,IAEzEJ,EAAiBG,GAAc,EAAAb,cAAca,SAMnC,QAAd,EAAAT,EAAQnB,cAAM,SAAEyC,KAAK,UAAeC,cAAcd,G,IAG/C,CAACJ,SAAQC,mBAClB,CAqEuCkB,CAAsBxB,GAsBzD,GArBAK,EAAOG,SAASiB,I,MACH,QAAX,EAAAvD,KAAKW,cAAM,SAAEyC,KAAKG,EAAM,IAG1BvD,KAAKwB,KAAOM,EAAQN,KAxExB,SAA2BM,EAAmBM,G,UAC5C,MAAM,aAAC5B,EAAY,WAAED,EAAU,UAAEE,GAAaqB,EACxC0B,GAAsB,IAAAC,mBAAkBjD,IAAiBA,IAAiB,EAAAkD,YAC1EC,GAAoB,IAAAF,mBAAkBlD,IAAeA,IAAe,EAAAmD,YACpEE,GAAmB,IAAAH,mBAAkBhD,IAAcA,IAAc,EAAAiD,aAElEtB,EAAiBjB,UAAYyC,GAAqBJ,GAAuBG,KACxEC,IACqB,QAAvB,EAAAxB,EAAiBzB,cAAM,SAAE4C,MAAM,UAAeM,gBAAgB,eAG5DzB,EAAiBf,eAAiB,EAAAM,iBAAiBC,WAAa4B,IAC3C,QAAvB,EAAApB,EAAiBzB,cAAM,SAAE4C,MAAM,UAAeM,gBAAgB,kBAG5DzB,EAAiBf,eAAiB,EAAAM,iBAAiBmC,SAAWH,IACzC,QAAvB,EAAAvB,EAAiBzB,cAAM,SAAE4C,MAAM,UAAeM,gBAAgB,gBAGpE,CAuDIE,CAAkBjC,EAASM,GAC3BpC,KAAKQ,aAAe,IAAI,IAAAwD,iBAAgB5B,EAAiB5B,0BACzDR,KAAKO,WAAa,IAAI,IAAAyD,iBAAgB5B,EAAiB7B,+CACvDP,KAAKS,UAAY,IAAI,IAAAuD,iBAAgB5B,EAAiB3B,sCAEtDT,KAAKE,cAAgBkC,EAAiBlC,cAEtCF,KAAKK,OAAS+B,EAAiB/B,OAC/BL,KAAKU,sBAAwB0B,EAAiB1B,sBAE9CV,KAAKgB,cAAgBoB,EAAiBpB,cACtChB,KAAKiB,iBAAmBmB,EAAiBnB,iBACzCjB,KAAKkB,gBAAkBkB,EAAiBlB,gBAExClB,KAAKmB,QAAUiB,EAAiBjB,QAC5BiB,EAAiBd,WAAac,EAAiBd,UAAU2C,OAAS,EACpE,IACEjE,KAAKiC,kBAAoB,IAAI,EAAAiC,sBAAsB9B,EAAiBd,U,CACpE,MAAO6C,GACI,QAAX,EAAAnE,KAAKW,cAAM,SAAE4C,MAAM,6D,CAInBvD,KAAKmB,UACI,QAAX,EAAAnB,KAAKW,cAAM,SAAEyD,KAAK,sFAGpBpE,KAAKqB,aAAee,EAAiBf,aAEjC,EAAAlB,eAAekE,SAAS3B,GAAGN,EAAiBrB,kBAE9Cf,KAAKsE,wBAA0BlC,EAAiBrB,iBAIhDf,KAAKsE,wBAA0B,IAAMlC,EAAiBrB,iBAGpD,EAAAZ,eAAekE,SAAS3B,GAAGN,EAAiBvB,OAE9Cb,KAAKuE,aAAenC,EAAiBvB,MAIrCb,KAAKuE,aAAe,IAAMnC,EAAiBvB,KAE/C,E,gECtOF,MAAqB2D,EAgBnB,YAAoBC,EAAgBC,GAClC1E,KAAKyE,MAAQA,EACbzE,KAAK0E,QAAUA,CACjB,CAEO,eAAOC,CAASnD,GACrB,IAAKA,EACH,OAAOgD,EAAQI,gBAAgB,qBAGjC,MAAM,MAACC,EAAK,KAAEC,GAAQtD,EAEtB,GAAIqD,SAA0D,KAAjBA,EAAME,OACjD,OAAOP,EAAQI,gBAAgB,oBAGjC,MAAMI,EAAU,IAAIR,GAAQ,GAG5B,OAFAQ,EAAQC,MAAQzD,EAETwD,CACT,CAEA,QAAIxD,GACF,OAAOxB,KAAKiF,KACd,CAEA,SAAIJ,GACF,OAAO7E,KAAKiF,MAAOJ,KACrB,CAEA,KAAAK,CAAMC,G,cACJ,MAAiB,UAAbA,EACe,QAAV,EAAAnF,KAAKiF,aAAK,eAAEJ,MACG,SAAbM,EACQ,QAAV,EAAAnF,KAAKiF,aAAK,eAAEH,KAEoD,QAAhE,EAAgC,QAAhC,EAAU,QAAV,EAAA9E,KAAKiF,aAAK,eAAEG,4BAAoB,eAAEC,MAAKC,GAAKA,EAAER,OAASK,WAAS,eAAED,KAE7E,CAEQ,sBAAON,CAAgBF,GAC7B,OAAO,IAAIF,GAAQ,EAAOE,EAC5B,EA1DF,W,mLCAA,mBAyBA,wBAGE,WAAA1C,CAAYF,GACV9B,KAAKuF,SAAWzD,QAAAA,EAAW,CAAC,CAC9B,CAKA,KAAA0D,GACE,OAAO,IAAI,UAASxF,KAAKuF,SAC3B,CAKA,aAAArF,CAAcA,GAEZ,OADAF,KAAKuF,SAASrF,cAAgBA,EACvBF,IACT,CAKA,MAAAK,CAAOA,GAEL,OADAL,KAAKuF,SAASlF,OAASA,EAChBL,IACT,CAKA,IAAAwB,CAAKA,GAEH,OADAxB,KAAKuF,SAAS/D,KAAOA,EACdxB,IACT,CAKA,YAAAQ,CAAaA,GAEX,OADAR,KAAKuF,SAAS/E,aAAeA,EACtBR,IACT,CAKA,UAAAO,CAAWA,GAET,OADAP,KAAKuF,SAAShF,WAAaA,EACpBP,IACT,CAKA,SAAAS,CAAUA,GAER,OADAT,KAAKuF,SAAS9E,UAAYA,EACnBT,IACT,CAKA,YAAAqB,CAAaoE,GAEX,OADAzF,KAAKuF,SAASlE,aAAeoE,EACtBzF,IACT,CAKA,eAAAkB,CAAgBA,GAEd,OADAlB,KAAKuF,SAASrE,gBAAkBA,EACzBlB,IACT,CAKA,aAAAgB,CAAcA,GAEZ,OADAhB,KAAKuF,SAASvE,cAAgBA,EACvBhB,IACT,CAKA,gBAAAiB,CAAiBA,GAEf,OADAjB,KAAKuF,SAAStE,iBAAmBA,EAC1BjB,IACT,CAKA,MAAAW,CAAOA,GAEL,OADAX,KAAKuF,SAAS5E,OAASA,EAChBX,IACT,CAKA,OAAAmB,CAAQA,GAEN,OADAnB,KAAKuF,SAASpE,QAAUA,EACjBnB,IACT,CAKA,SAAAsB,CAAUoE,GAER,OADA1F,KAAKuF,SAASjE,UAAYoE,EACnB1F,IACT,CAKA,gBAAAe,CACEA,GASA,OADAf,KAAKuF,SAASxE,iBAAmBA,EAC1Bf,IACT,E,8eC7JF,mBAEA,aACA,aACA,UAEA,aACA,aACA,aAEA,aACA,aACA,UACA,UACA,aACA,UACA,UAEA,SACA,UAGA,UACA,SAEA,UAEA,IAAK2F,GAAL,SAAKA,GACH,mCACA,iCACA,sBACD,CAJD,CAAKA,IAAAA,EAAW,KAiBhB,qBA6BE,WAAA3D,CACUF,EACA8D,EACRC,GAFQ,KAAA/D,QAAAA,EACA,KAAA8D,SAAAA,EA9BF,KAAAE,MAAqBH,EAAYI,aAiCvC/F,KAAKgG,QAAUH,EAAUG,QACzBhG,KAAKiG,SAAWJ,EAAUI,SAC1BjG,KAAKkG,QAAUL,EAAUK,QAEzB,MAAM,SAACC,EAAQ,kBAAEC,GAAqBP,EAChCQ,EAAS,IAAI,UAAcvE,GAEjC,IAAKuE,EAAOhG,SAAWgG,EAAOlF,QAC5B,MAAM,IAAImF,MAAM,iDAGlB,IAAKD,EAAO7E,KACV,MAAM,IAAI8E,MAAM,6CAGlBtG,KAAKqG,OAASA,EACdrG,KAAKW,OAAS0F,EAAO1F,OAErBX,KAAKuG,KAAKX,EAAUO,EAAUC,EAChC,CAEc,IAAAG,CAAKX,EAAqBO,EAAoCC,G,mDAC1E,MAAMI,EAAgB,IAAI,UAAcxG,KAAKqG,OAAOhG,OAAQL,KAAKqG,OAAQT,GACzE5F,KAAKa,MAAQb,KAAKqG,OAAO9B,aAAaiC,GACtCxG,KAAKa,MAAM4F,SAASzG,KAAKqG,OAAO7E,MAChC,MAAMkF,EAAoB,IAAI,UAAkB1G,KAAKa,MAAOuF,EAAmBD,GAM/E,GALAnG,KAAK2G,UAAY,IAAI,UAAU3G,KAAKa,aAG9Bb,KAAKqG,OAAOpE,kBAAkB2E,SAAS5G,KAAKqG,OAAO7E,KAAKqD,MAAO6B,GAEjE1G,KAAKqG,OAAOlF,QACdnB,KAAK6G,eAAiB,IAAI,EAAAC,mBAC1B9G,KAAKe,iBAAmB,IAAI,EAAAgG,qBAE5B/G,KAAKgH,kBACA,CACLhH,KAAK6G,eAAiB,IAAI,EAAAI,sBAAsBT,GAEhD,MAAMU,GAAY,IAAAC,uBAAsBT,EAAmB1G,KAAKW,OAAQ,CACtEyG,IAAK,IAAMpH,KAAKgH,cAChBK,MAAO,IAAMrH,KAAKgH,gBAGdjG,EAAmBf,KAAKqG,OAAOhF,eAAiB,EAAAM,iBAAiBC,UACnE,IAAI,UACJ5B,KAAKqG,OAAOhG,OACZL,KAAKqG,OAAO7E,KACZgF,EACAZ,EAAS0B,WACT,IAAMtH,KAAKa,MAAO0G,SAClBL,EACAlH,KAAKqG,OAAO3F,uBAEZ,IAAI,UACJV,KAAKqG,OACL,IAAI,UAAUrG,KAAKqG,OAAOhG,OAAQL,KAAKqG,OAAQrG,KAAK4F,SAASxB,KAAMpE,KAAK4F,SAAS4B,WACjF,IAAMxH,KAAKa,MAAO0G,SAClBL,GACCO,GAAMzH,KAAK0H,uBAAuBD,KAGvCzH,KAAKe,iBAMJ,QANuB,EAAmC,QAAnC,KAAAf,KAAKqG,QAAO/B,+BAAuB,sBACzDkC,EACAxG,KAAKa,MACL6F,GACA,IAAM1G,KAAKgH,gBACVS,GAAMzH,KAAK0H,uBAAuBD,YACpC,QAAI1G,C,CAGPf,KAAK2H,O,IAGP,QAAAlB,CAASjF,GACP,MAAMiB,EAAY,IAAI,EAAAQ,cACjBR,EAAUC,GAAGlB,IAQlBxB,KAAKa,MAAO4F,SAASjF,GACrBxB,KAAKe,iBAAkB0F,SAASjF,IAR9BiB,EAAUS,SAASZ,SAASiB,I,MACf,QAAX,EAAAvD,KAAKW,cAAM,SAAEyC,KAAKG,EAAM,GAQ9B,CAEQ,KAAAoE,GACF3H,KAAKqG,OAAOlF,UAIhBnB,KAAKe,iBAAkB4G,QACvBC,YAAW,K,QACT,IAAK5H,KAAK6H,cAAe,CACvB,MAAMC,EAAM,gDAAiD9H,KAAKqG,OAAOnG,gTAMnEqD,EAAQ,IAAI+C,MAAMwB,GAKxB,OAJA9H,KAAK8F,MAAQH,EAAYoC,OACzB/H,KAAKgI,gBAAkBzE,EACR,QAAf,EAAAvD,KAAKiI,kBAAU,mBAAG1E,GAEA,QAAX,EAAAvD,KAAKW,cAAM,eAAEyC,KAAK0E,E,IAE1B9H,KAAKqG,OAAOnG,eACjB,CAEA,WAAA2H,GACE,OAAO7H,KAAK8F,QAAUH,EAAYuC,WACpC,CAEA,qBAAAC,GAOE,OAAInI,KAAKoI,mBACApI,KAAKoI,mBAKVpI,KAAK8F,QAAUH,EAAYuC,aAC7BlI,KAAKoI,mBAAqBC,QAAQC,QAAQtI,MACnCA,KAAKoI,oBAKVpI,KAAK8F,QAAUH,EAAYoC,QAC7B/H,KAAKoI,mBAAqBC,QAAQE,OAAOvI,KAAKgI,iBACvChI,KAAKoI,qBAGTpI,KAAKoI,qBACRpI,KAAKoI,mBAAqB,IAAIC,SAAQ,CAACC,EAASC,KAC9CvI,KAAKwI,YAAcF,EACnBtI,KAAKiI,WAAaM,CAAM,KAGrBvI,KAAKoI,mBACd,CAEA,aAAAK,CACEC,EACAC,GAEA,OAAO3I,KAAK4I,aAAaF,EAAKC,EAAc,EAAAE,gBAAgBC,MAAM5D,KACpE,CAEA,mBAAA6D,CACEL,EACAC,GAEA,OAAO3I,KAAK4I,aAAaF,EAAKC,EAAc,EAAAE,gBAAgBC,KAC9D,CAEA,aAAAE,CAAcN,EAAaC,GACzB,OAAO3I,KAAK4I,aAAaF,EAAKC,EAAc,EAAAE,gBAAgBI,MAAM/D,KACpE,CAEA,mBAAAgE,CAAoBR,EAAaC,GAC/B,OAAO3I,KAAK4I,aAAaF,EAAKC,EAAc,EAAAE,gBAAgBI,KAC9D,CAEA,eAAAE,CAAgBT,EAAaC,GAC3B,OAAO3I,KAAK4I,aAAaF,EAAKC,EAAc,EAAAE,gBAAgBO,QAAQlE,KACtE,CAEA,qBAAAmE,CAAsBX,EAAaC,GACjC,OAAO3I,KAAK4I,aAAaF,EAAKC,EAAc,EAAAE,gBAAgBO,OAC9D,CAEA,eAAAE,CAAgBZ,EAAaC,GAC3B,OAAO3I,KAAK4I,aAAaF,EAAKC,EAAc,EAAAE,gBAAgBU,QAAQrE,KACtE,CAEA,qBAAAsE,CAAsBd,EAAaC,GACjC,OAAO3I,KAAK4I,aAAaF,EAAKC,EAAc,EAAAE,gBAAgBU,OAC9D,CAEA,SAAAE,CAAUf,EAAaC,GACrB,OAAO3I,KAAK4I,aAAaF,EAAKC,EAAc,EAAAE,gBAAgBU,QAAQrE,KACtE,CAEA,eAAAwE,CAAgBhB,EAAaC,GAC3B,OAAO3I,KAAK4I,aAAaF,EAAKC,EAAc,EAAAE,gBAAgBU,OAC9D,CAEA,gBAAAI,G,MACE,MAAM3E,EAAU,UAAQL,SAAS3E,KAAKqG,OAAO7E,MAC7C,IAAKwD,EAAQP,MAAO,CAClB,MAAMlB,EAAQ,IAAI,EAAAqG,YAChB,GAAmB,QAAf,EAAA5E,EAAQN,eAAO,QAAI,8CAIzB,OAFA1E,KAAKgG,QAAQzC,GAEN8E,QAAQC,QAAQ,G,CAGzB,MAAO5C,EAAOvB,GAAKnE,KAAKa,MAAOgJ,IAAI,UAAUC,OACvCC,EAASnJ,OAAOyB,KAAKqD,GAAOsE,KAAIC,I,MACpC,MAAMC,EAAalK,KAAK2G,UAAWwD,SAASF,GAC5C,MAAO,CAACA,UAASG,KAAMF,EAAWE,KAAMC,OAAQH,EAAWG,OAAQnF,MAAuB,QAAhB,EAAAgF,EAAWhF,aAAK,eAAEuE,UAAU,IAGxG,OAAOpB,QAAQC,QAAQyB,EACzB,CAEM,KAAAO,G,qDACEtK,KAAK6G,eAAgByD,QACN,QAArB,EAAAtK,KAAKe,wBAAgB,SAAEuJ,QACvBtK,KAAKa,MAAOyJ,O,IAGd,KAAAC,CAAMC,EAAmBC,GACvB,MAAMC,EAAc,IAAI,EAAAC,YAAY3K,KAAKqG,OAAO7E,KAAMgJ,EAAWxK,KAAK4F,SAASxB,KAAKwG,QAASH,QAAAA,EAAe,GAC5GzK,KAAK6G,eAAgBgE,OAAOH,EAE9B,CAEM,KAAAI,CAAMC,G,yCACV,IAGE,aAFM/K,KAAK6G,eAAgBiE,QAC3BC,SAAAA,GAAW,IACJ,C,CACP,MAAOC,GAEP,OADAD,SAAAA,GAAW,IACJ,C,CAEX,G,CAEA,YAAAnC,CACEqB,EACAtB,EACAsC,G,UAEA,MAAMjG,EAAU,UAAQL,SAAS3E,KAAKqG,OAAO7E,MAC7C,IAAKwD,EAAQP,MAAO,CAClB,MAAMlB,EAAQ,IAAI,EAAAqG,YAChB,GAAmB,QAAf,EAAA5E,EAAQN,eAAO,QAAI,8CAIzB,OAFA1E,KAAKgG,QAAQzC,GAEN,CAAC0G,UAASG,KAAM,EAAAc,YAAY5E,MAAO+D,OAAQ9G,EAAMmB,QAASQ,MAAOyD,E,CAG1E,MAAMuB,EAAalK,KAAK2G,UAAWwD,SAASF,GAE5C,GAAIC,EAAWE,OAAS,EAAAc,YAAYC,aAAc,CAEhD,MAAM5H,EAAQ,IAAI,EAAAqG,YAAYM,EAAWG,QAGzC,OAFArK,KAAKgG,QAAQzC,GAEN,CAAC0G,UAASG,KAAMF,EAAWE,KAAMC,OAAQH,EAAWG,OAAQnF,MAAOyD,E,CAGvE3I,KAAK6H,cAOR7H,KAAK6G,eAAgBgE,OAAOX,EAAWkB,YAAYpL,KAAKqG,OAAO7E,OANpD,QAAX,EAAAxB,KAAKW,cAAM,SAAEyC,KACX,wGAQJ,MAAM,YAACiI,EAAW,MAAEnG,GAAS+F,EAA8B,QAAhB,EAAAf,EAAWhF,aAAK,eAAEuE,WAC7D,OAAO4B,EACH,CAACpB,UAASG,KAAMF,EAAWE,KAAMC,OAAQH,EAAWG,OAAQnF,SAC5D,CAAC+E,UAASG,KAAM,EAAAc,YAAYI,UAAWjB,OAAQ,gBAAiBnF,MAAOyD,EAC7E,CAEQ,sBAAAjB,CAAuBD,G,MAC7B,MAAMlE,EACO,MAAXkE,EAAE8D,KAAe,IAAIjF,MAAM,qDAAuDmB,EAEpFzH,KAAKgG,QAAQzC,GACbvD,KAAKiG,SAAS1C,GAETvD,KAAK6H,gBACR7H,KAAK8F,MAAQH,EAAYoC,OACzB/H,KAAKgI,gBAAkBzE,EACR,QAAf,EAAAvD,KAAKiI,kBAAU,mBAAG1E,GAEtB,CAEQ,WAAAyD,G,QACDhH,KAAK6H,gBACR7H,KAAK8F,MAAQH,EAAYuC,YACd,QAAX,EAAAlI,KAAKW,cAAM,SAAEyD,KAAK,kCACF,QAAhB,EAAApE,KAAKwI,mBAAW,mBAAGxI,MACnBA,KAAKkG,UAET,E,yZC5XF,gBAGA,UAGA,8BAGE,WAAAlE,CAAYV,GACV,MAAMoE,GAAkBpE,GAAa,IAAI0I,KAAKwB,GAAqB,OAAD,wBAAKA,GAAI,CAAEC,iBAAkBD,EAAKC,kBAAoB,CAAC,CAACC,GAAI,KAAMjC,UAAW+B,EAAK/B,gBAE9IkC,GAAO,IAAAC,gBAAelG,GAC5B1F,KAAK6L,QAAU,CACbnG,MAAOiG,EAAKjG,MACZ6B,QAAS,EAEb,CAEA,QAAAX,CAASkF,EAAmBpF,EAAuCqE,GACjE,OAAO,IAAI1C,SAAQ,CAACC,EAASC,KAC3B,IAAI,IAAA9E,mBAAkBzD,KAAK6L,SACzB,OAAOvD,IAQT5B,EAAkBH,KAAKuF,EAAW9L,KAAK6L,SALd,KACvBvD,IACAyC,SAAAA,GAAY,GAGoD,GAEtE,E,8FC7BF,8BAGE,WAAA/I,GACEhC,KAAK6L,QAAU,CACbnG,MAAO,CAAC,EACR6B,QAAS,EAEb,CAEA,QAAAX,CAASkF,EAAmBpF,EAAuCqE,GACjE,OAAO,IAAI1C,SAAQ,CAACC,EAASC,KAC3BD,IACAyC,SAAAA,GAAY,GAEhB,E,4fCnBF,aACA,YACA,W,8FCFa,EAAArH,YAAc,GACd,EAAAqI,OAAiB,U,4JCO9B,mBAKA,gBAEE,WAAA/J,CACmBnB,EACAuF,EACA4F,GAFA,KAAAnL,MAAAA,EACA,KAAAuF,kBAAAA,EACA,KAAA4F,SAAAA,CAEnB,CAEA,IAAAzF,CAAKuF,EAAmBG,EAA4BlB,GAClD,GAAIe,IAAc9L,KAAKa,MAAMW,KAAKqD,MAEhC,YADAkG,SAAAA,KAIF,MAAMmB,EAAkBlM,KAAKoG,oBACvB+F,EAAUC,IACdpM,KAAKa,MAAM0F,KAAK0F,GAAS,KAEvB5D,QAAQC,UAAU+D,MAAK,KACrB,GAAIH,EAAiB,CACnB,MAAMI,EAAc1L,OAAOyB,KAAK4J,GAC7BM,SAASC,IACR,MAAMC,GAAiBL,aAAO,EAAPA,EAAUI,KAAc,CAAC,EAC1CE,EAAiBT,EAAQO,GACzBG,EAAa,OAAH,wBAAOF,GAAmBC,GAC1C,OAAO9L,OAAOyB,KAAKsK,GAChBC,QAAQlE,GAAgB1I,KAAK6M,UAAUJ,GAAkBA,EAAe/D,GAAMgE,GAAkBA,EAAehE,KAAM,IAE5H4D,EAAYrI,OAAS,GAAKjE,KAAKgM,SAASM,E,KAG5CvB,SAAAA,GAAY,GACZ,EAGJ,GAAImB,EAAiB,CACnB,MAAOxG,EAAO6B,GAAWvH,KAAKa,MAAMgJ,IAAI,UAAUC,OAKlDqC,EAJgB,CACdzG,QACA6B,W,MAIF4E,GAEJ,CAEA,MAAAW,CAAOhB,EAAmB1B,EAAiBuB,EAAuBZ,GAChE,GAAIe,IAAc9L,KAAKa,MAAMW,KAAKqD,MAEhC,YADAkG,SAAAA,KAIF,MAAM,IAACrC,GAAOiD,EACRO,EAAkBlM,KAAKoG,oBACvB2G,EAAYC,IAChBhN,KAAKa,MAAMiM,OAAO1C,EAAMuB,GAAM,KAE5BtD,QAAQC,UAAU+D,MAAK,KACjBH,GAAmBlM,KAAK6M,UAAUG,EAASrB,EAAKjD,KAClD1I,KAAKgM,SAAS,CAACtD,G,IAInBqC,SAAAA,GAAY,GACZ,EAEAmB,EAEFa,EADa/M,KAAKa,MAAMoM,IAAI7C,EAAM1B,SACjB3G,GAEjBgL,GAEJ,CAEQ,SAAAF,CAAUT,EAAsBc,GACtC,OAAQd,IAAYc,GAAWA,EAAQ3F,QAAU6E,EAAQ7E,OAC3D,E,gECxFF,8BACU,KAAA4F,iBAAsD,CAAC,CAmCjE,CAjCE,GAAAF,CAAIT,EAAmB9D,G,MACrB,OAAuC,QAAhC,EAAA1I,KAAKmN,iBAAiBX,UAAU,eAAG9D,EAC5C,CAEA,GAAA0E,CAAIZ,EAAmB9D,EAAaxD,GAC5BsH,KAAaxM,KAAKmN,mBACtBnN,KAAKmN,iBAAiBX,GAAa,CAAC,GAEtCxM,KAAKmN,iBAAiBX,GAAW9D,GAAOxD,CAC1C,CAEA,MAAAmI,CAAOb,EAAmB9D,GACxB,MAAM4E,EAAQtN,KAAKmN,iBAAiBX,GAChCc,UACKA,EAAM5E,EAEjB,CAEA,SAAA6E,GACEvN,KAAKmN,iBAAmB,CAAC,CAC3B,CAEA,SAAAK,CAAUzC,GACRnK,OAAO6M,QAAQzN,KAAKmN,kBAAkB7K,SAAQ,EAAEkK,EAAWkB,MACzD9M,OAAO6M,QAAQC,GAAQpL,SAAQ,EAAEoG,EAAKxD,MACpC6F,EAASyB,EAAW9D,EAAKxD,EAAM,GAC/B,GAEN,CAEA,SAAAyI,CAAUC,GACRA,EAAMJ,UAAUxN,KAAKoN,IAAIS,KAAK7N,MAChC,E,idCnCF,gBAUa,EAAA8N,kBAAoB,CAC/BpH,EACA/F,EACAoN,EAAqC,YAElC,CACHC,gBAAiB,EAAApC,eACjBqC,YAAa,CAAOnC,GAAoBpG,WAAkB,OAAD,6BACvD,MAAMwI,EAA8B,CAClCxI,MAAOA,EACP6B,QAAS,GAGX5G,SAAAA,EAAQwN,MAAM,yBACdzH,EAAkBH,KAAKuF,EAAWoC,EAAUH,EAC9C,MAGW,EAAAK,oBAAsB,CACjC1H,EACA/F,EACA0N,EAAuC,YAEpC,CACHL,gBAAiB,EAAAM,iBACjBL,YAAa,CAAOnC,EAAmBH,IAAuB,OAAD,6BACtC,KAAjBA,aAAI,EAAJA,EAAM1H,QAKV0H,SAAAA,EAAMrJ,SAAQiM,IACZ5N,SAAAA,EAAQwN,MAAM,YAAaI,EAAK5C,KAAKjD,UAAY6F,EAAKnE,KAAKoC,aAC3D9F,EAAkBoG,OAAOhB,EAAWyC,EAAKnE,KAAMmE,EAAK5C,KAAM0C,EAAuB,IANjFA,SAAAA,GAQJ,MAIW,EAAAlH,sBAAwB,CACnCT,EACA/F,EACA6N,KAMA,MAAMtH,EAAY,IAAIuH,IAGtB,OAFAvH,EAAUkG,IAAI,OAAO,IAAAU,mBAAkBpH,EAAmB/F,EAAQ6N,aAAkB,EAAlBA,EAAoBpH,MACtFF,EAAUkG,IAAI,SAAS,IAAAgB,qBAAoB1H,EAAmB/F,EAAQ6N,aAAkB,EAAlBA,EAAoBnH,QACnFH,CAAS,C,4fChElB,aACA,aACA,Y,cCFA,IAAYvF,E,2EAAZ,SAAYA,GACV,oBACA,uBACD,CAHD,CAAYA,IAAgB,mBAAhBA,EAAgB,I,0NCE5B,6BACE,KAAA2I,GACA,CAEA,KAAA3C,GACA,CAEA,IAAA+G,GACA,CAEA,QAAAjI,GACA,E,kECbF,gBAIA,UAEA,UAGA,gBAWE,WAAAzE,CACEqE,EACiBsI,EACAC,EACA1H,EACA2H,GAHA,KAAAF,UAAAA,EACA,KAAAC,kBAAAA,EACA,KAAA1H,UAAAA,EACA,KAAA2H,aAAAA,EAfX,KAAAC,SAAU,EAiBhB9O,KAAKW,OAAS0F,EAAO1F,OACrBX,KAAKkB,gBAAkBmF,EAAOnF,gBAC9BlB,KAAKwB,KAAO6E,EAAO7E,IACrB,CAEQ,IAAAuN,G,MACN,GAAI/O,KAAK8O,QACP,OAGF,MAAME,EAAYC,KAAKC,MACZ,QAAX,EAAAlP,KAAKW,cAAM,SAAEwN,MAAM,iDACnBnO,KAAK2O,UAAUQ,YAAYnP,KAAK4O,oBAAqB5O,KAAKwB,MAAM,CAACwJ,EAAKoE,K,kBACpE,MAAMC,EAAUJ,KAAKC,MAAQF,EACvBM,EAAWC,KAAKC,IAAIxP,KAAKkB,gBAAkBmO,EAAS,GAG1D,GADW,QAAX,EAAArP,KAAKW,cAAM,SAAEwN,MAAM,qCAAsCkB,EAASC,GAC9DtE,EAAK,CACP,MAAM,OAACyE,GAAUzE,EACjB,GAAIyE,KAAW,IAAAC,mBAAkBD,GAAS,CACxC,MAAM/K,GAAU,IAAAiL,kBAAiB3E,EAAK,mBAKtC,OAJW,QAAX,EAAAhL,KAAKW,cAAM,SAAE4C,MAAMmB,QACF,QAAjB,EAAA1E,KAAK6O,oBAAY,mBAAG,IAAI,EAAAe,aAAalL,EAAS+K,I,CAKrC,QAAX,EAAAzP,KAAKW,cAAM,SAAEyC,MAAK,IAAAuM,kBAAiB3E,EAAK,kBAAmB,c,KACtD,CACL,IAAI6E,EAAe,GACf/D,EAAqB,QAAT,EAAA9L,KAAKwB,YAAI,eAAEqD,MACvBiL,EAA2D9P,KAAKkH,UAAU+F,IAAI,SAElF,GAAImC,EAAM,CACR,MAAM1K,EAAUqL,KAAKC,MAAMZ,GAC3B,GAA4B,cAAxB1K,EAAQuL,YAA6B,CACvC,OAAQvL,EAAQiH,KAAKuE,WACnB,KAAK,EAAAC,wBAAwB9I,MAC3ByI,EAAwB9P,KAAKkH,UAAU+F,IAAI,SAC3C,MACF,KAAK,EAAAkD,wBAAwBC,KAC3BN,EAAwB9P,KAAKkH,UAAU+F,IAAI,SAI7C4C,eAAc/D,aAAapH,EAAQiH,K,EAIzC,MAAMA,EAA6C,QAAtC,EAAAmE,aAAqB,EAArBA,EAAuB9B,uBAAe,sBAAG6B,GACpB,QAAlC,EAAAC,aAAqB,EAArBA,EAAuB7B,mBAAW,gBAAGnC,EAAWH,E,CAKlD3L,KAAKqQ,cAAgBzI,YAAW,KAC9B5H,KAAK+O,MAAM,GACVO,EAAS,GAEhB,CAEA,QAAA7I,CAASjF,GACPxB,KAAKwB,KAAO,OAAH,UAAOA,EAClB,CAEA,KAAA8I,GACEtK,KAAK0O,MACP,CAEA,KAAA/G,GACE3H,KAAK+O,MACP,CAEA,IAAAL,GACM1O,KAAKqQ,gBACPC,aAAatQ,KAAKqQ,eAClBrQ,KAAKqQ,mBAAgBtO,GAEvB/B,KAAK8O,SAAU,CACjB,E,wYCtGF,gBACA,UAKA,gBAKE,WAAA9M,CACE3B,EACAgG,EACAjC,EACiBoD,GAAA,KAAAA,SAAAA,EAEjBxH,KAAKuQ,SAAU,IAAAC,gBAAenQ,EAAQ+D,GACtCpE,KAAKyQ,IAAMpK,EAAO9F,UACpB,CAMc,OAAAmQ,CACZC,EACA7O,G,yCAKA,MAAM8O,QAAY5Q,KAAKwH,SAASqJ,MAAMF,EAAY7O,GAE5CsN,QAAawB,EAAIE,OAEvB,MAAO,CAACF,MAAKxB,OACf,G,CAEM,WAAAD,CAAY4B,EAAmBC,EAAcC,G,yCACjD,MAAMnP,EAA2B,CAC/BoP,OAAQ,OACRX,QAASvQ,KAAKuQ,QACdnB,KAAMW,KAAKoB,UAAUH,IAEvB,IACE,MAAM,IAACJ,EAAG,KAAExB,SAAcpP,KAAK0Q,QAAQ,GAAI1Q,KAAKyQ,iBAAmBM,QAAAA,EAAa,IAAMjP,GACtF,GAAmB,MAAf8O,EAAInB,QAAiC,MAAfmB,EAAInB,OAAgB,CAC5C,MAAMzE,EAAM,IAAI,EAAAoG,eAAe,2BAA4BR,EAAInB,SAAWmB,EAAInB,QAC9E,OAAOwB,EAAGjG,OAAKjJ,E,CAEjB,OAAOkP,OAAGlP,EAA0B,MAAf6O,EAAInB,OAAiB,KAAOL,E,CACjD,MAAOpE,GACP,OAAOiG,EAAGjG,OAAKjJ,E,CAEnB,G,kECcF,UAlEA,MAME,WAAAC,CACE3B,EACAmB,EACAgF,EACA6K,EACiBzC,EACA1H,EACjBxG,GAFiB,KAAAkO,kBAAAA,EACA,KAAA1H,UAAAA,EAGjB,MAAM,OAACvG,EAAM,aAAEH,GAAgBgG,EAE/BxG,KAAKW,OAASA,EACdX,KAAKqR,OAASA,EACdrR,KAAKqR,OAAOhL,OAAO,CACjBhG,SACAG,eACA8Q,aAAc5Q,EACdc,OACAb,SACAiO,sBAGF5O,KAAKkH,UAAU5E,SAAQ,EAAE0L,kBAAiBC,eAAczD,K,MAC3C,QAAX,EAAAxK,KAAKqR,cAAM,SAAEE,YAAY/G,GAAYgH,I,MAGnC,GAFW,QAAX,EAAAxR,KAAKW,cAAM,SAAEwN,MAAM,YAAa3D,WAE5BgH,aAAK,EAALA,EAAO7F,KAAM,CACf,MAAM,aAACkE,EAAY,UAAE/D,GAAa0F,EAAM7F,KAClCA,EAAOqC,EAAgB6B,GAC7B5B,EAAYnC,EAAWH,E,IAEzB,GAEN,CAEA,QAAAlF,CAASjF,G,MACI,QAAX,EAAAxB,KAAKqR,cAAM,SAAE5K,SAASjF,EACxB,CAEA,KAAAmG,G,MACE3H,KAAKyR,uBAEM,QAAX,EAAAzR,KAAKqR,cAAM,SAAEK,SACf,CAEQ,oBAAAD,G,MACNzR,KAAK2R,2BAA6B1C,KAAKC,MAC5B,QAAX,EAAAlP,KAAKW,cAAM,SAAEyD,KAAK,uCAAwCpE,KAAK2R,6BACjE,CAEA,KAAArH,GACEtK,KAAK0O,MACP,CAEA,IAAAA,G,MACa,QAAX,EAAA1O,KAAKqR,cAAM,SAAE/G,QACbtK,KAAKqR,YAAStP,CAChB,E,4fCtEF,YACA,YACA,YACA,aACA,aACA,aACA,aACA,aACA,Y,eCHA,IAAYoO,E,kFAAZ,SAAYA,GACV,cACA,eACD,CAHD,CAAYA,IAAuB,0BAAvBA,EAAuB,I,iGCJnC,MAAMyB,EAAmC,CACvC,EAAK,IACL,EAAK,IACL,EAAK,IACL,EAAK,IACL,EAAK,IACL,EAAK,IACL,EAAK,IACL,EAAK,IACL,EAAK,IACL,EAAK,KAGP,SAASC,EAAaC,EAAe7N,GACnC,IAAI8N,EAAI,eAAiBD,EAEzB,OAD+BC,EAAEC,MAAMD,EAAE9N,OAASA,GACpBgO,MAAM,IAAIjI,KAAIkI,GAAKN,EAASM,KAAIC,KAAK,GACrE,CAGA,mCAAwCrB,GACtCA,EAAOA,EAAKsB,QAAQ,MAAO,IAC3B,MAAMrB,EAAY9B,KAAKC,MACjBmD,EAAgBR,EAAad,EAAWA,EAAUuB,WAAWrO,QAE7D0D,EAAQ4H,KAAKC,IAAID,KAAKgD,MAAMhD,KAAKiD,SAAW1B,EAAK7M,QAAS,GAEhE,MAAO,GAAI4N,EAAalK,EAAO,KAAOkK,EAAaQ,EAAcpO,OAAQ,KAAO6M,EAAKkB,MAAM,EAAGrK,KAAW0K,IAAkBvB,EAAKkB,MAAMrK,IACxI,C,mKC7BA,MAAaiI,UAAqBtJ,MAGhC,WAAAtE,CAAY0C,EAAiB+K,GAC3BgD,MAAM/N,GACN1E,KAAKyP,OAASA,EACdzP,KAAK8E,KAAO,gBACd,EAPF,iBAUA,MAAasM,UAAuB9K,MAGlC,WAAAtE,CAAY0C,EAAiB6G,GAC3BkH,MAAM/N,GACN1E,KAAKuL,KAAOA,EACZvL,KAAK8E,KAAO,kBACd,EAPF,mBAUA,MAAa4N,UAAgCpM,MAC3C,WAAAtE,CAAY0C,GACV+N,MAAM/N,GACN1E,KAAK8E,KAAO,2BACd,EAJF,4BAQA,MAAa8E,UAAoBtD,MAC/B,WAAAtE,CAAY0C,GACV+N,MAAM/N,GACN1E,KAAK8E,KAAO,eACd,EAJF,gBAOA,6BAAkC2K,GAChC,QAAIA,GAAU,KAAOA,EAAS,MACV,MAAXA,GAA6B,MAAXA,GAA6B,MAAXA,CAG/C,C,kECxCA,gBAEA,UASA,MAAqBkD,EACnB,YACSvI,EACAlF,EACAmF,GAFA,KAAAD,KAAAA,EACA,KAAAlF,MAAAA,EACA,KAAAmF,OAAAA,CAET,CAEA,mBAAOuI,CAAa3I,GAClB,OAAO,IAAI0I,EAAW,EAAAzH,YAAYC,aAAc,KAAM,mBAAoBlB,IAC5E,CAEA,cAAO4I,CAAQC,GACb,OAAO,IAAIH,EAAW,EAAAzH,YAAY6H,MAAOD,EAAK,eAChD,CAEA,WAAA1H,CAAY5J,G,UACV,GAAIxB,KAAKoK,OAAS,EAAAc,YAAY6H,MAC5B,OAAO,KAGT,MAAMC,EAA8B,QAAV,EAAAhT,KAAKkF,aAAK,eAAE+N,WAAW5N,MAAK6N,IAAI,MAAC,OAAAA,EAAEhO,SAAoB,QAAV,EAAAlF,KAAKkF,aAAK,eAAEuE,UAAU,IAC7F,OAAO,IAAI,EAAA0J,UAAU3R,EAAgB,QAAV,EAAAxB,KAAKkF,aAAK,eAAEwG,GAAKsH,EAA8B,QAAV,EAAAhT,KAAKkF,aAAK,eAAEkO,iBAC9E,EAvBF,W,4JCVA,mBAEA,aAKA,gBACE,WAAApR,CAAoBnB,GAAA,KAAAA,MAAAA,CACpB,CAMA,QAAAsJ,CACEF,GAEA,MAAMuB,EAAOxL,KAAKa,MAAMoM,IAAI,UAAUnD,MAAOG,GAC7C,OAAKuB,EAIE,UAAWqH,QAAQrH,GAHjB,UAAWoH,aAAa3I,EAInC,E,8ECtBF,IAAYiB,E,sEAAZ,SAAYA,GACV,kCACA,gBACA,wBACA,8BACA,eACD,CAND,CAAYA,IAAW,cAAXA,EAAW,I,eCDvB,IAAYmI,E,4EAAZ,SAAYA,GACV,kBACA,oBACA,kBACA,cACA,UACD,CAND,CAAYA,IAAiB,oBAAjBA,EAAiB,I,4fCF7B,Y,4fCAA,aACA,aACA,aACA,aACA,aACA,Y,oGCLA,gBAEA,IAAYC,GAAZ,SAAYA,GAEV,sBACA,0BACA,gCACA,oCAGA,gBACA,sBAGA,sBACA,0BAGA,0BACA,sBAGA,0BACA,gCAGA,oBACA,sBAGA,kBACA,mBACD,CA9BD,CAAYA,IAAa,gBAAbA,EAAa,KAgCzB,MAAaC,EAEX,WAAAvR,CAA6BwR,EAAoCC,GAApC,KAAAD,UAAAA,EAAoC,KAAAC,KAAAA,CACjE,CAEO,OAAAC,CAAQxO,EAAeyO,GAC5B,OAAc,OAAVzO,GAAqC,OAAnByO,GAIf3T,KAAKyT,KAAKvO,EAAOyO,EAC1B,CAgBQ,sBAAOC,CACbC,EACAC,GACA,MAAO,CAACC,EAAgBC,KACtB,MAAMC,EAAmBC,WAAWH,GAC9BI,EAAmBD,WAAWF,GAGpC,GAAII,MAAMH,IAAqBG,MAAMD,GACnC,OAAO,EAIT,MAAMpK,EAASwF,KAAK8E,KAAKJ,EAAmBE,GAC5C,OAAOpK,IAAW8J,GAA2B9J,IAAW+J,CAA4B,CAExF,CAiFO,UAAO7G,CAAIuG,GAChB,MAAMc,EAAKf,EAASgB,IAAIlP,MAAKmP,GAAKA,EAAEhB,YAAcA,IAElD,OAAOc,QAAAA,EAAM,IAAIf,EAASC,GAAW,CAACO,EAAgBC,KAAmB,GAC3E,EAhIF,aAcyB,EAAAS,SACrB,IAAIlB,EAASD,EAAcmB,SAAUlB,EAASK,iBAAiB,GAAI,IAE9C,EAAAc,cACrB,IAAInB,EAASD,EAAcoB,cAAenB,EAASK,iBAAiB,EAAG,IAElD,EAAAe,WACrB,IAAIpB,EAASD,EAAcqB,WAAYpB,EAASK,gBAAgB,EAAG,IAE9C,EAAAgB,gBACrB,IAAIrB,EAASD,EAAcsB,gBAAiBrB,EAASK,gBAAgB,EAAG,IAsBnD,EAAAiB,MACrB,IAAItB,EAASD,EAAcuB,OAAO,CAACd,EAAgBC,IAAmBD,IAAWC,IAE5D,EAAAc,SACrB,IAAIvB,EAASD,EAAcwB,UAAU,CAACf,EAAgBC,IAAmBD,IAAWC,IAG/D,EAAAe,SACrB,IAAIxB,EAASD,EAAcyB,UAAU,CAAChB,EAAgBC,IAAmBD,EAAOiB,SAAShB,KAEpE,EAAAiB,YACrB,IAAI1B,EAASD,EAAc4B,YAAY,CAACnB,EAAgBC,KAAoBD,EAAOiB,SAAShB,KAGvE,EAAAmB,WACrB,IAAI5B,EAASD,EAAc6B,YAAY,CAACpB,EAAgBC,IAAmBD,EAAOqB,WAAWpB,KAExE,EAAAqB,SACrB,IAAI9B,EAASD,EAAc+B,UAAU,CAACtB,EAAgBC,IAAmBD,EAAOuB,SAAStB,KAGpE,EAAAuB,WACrB,IAAIhC,EAASD,EAAciC,YAAY,CAACC,EAAiBxB,IAAmB,EAAAyB,MAAMC,WAAWF,GAASG,KAAK3B,KAEtF,EAAA4B,cACrB,IAAIrC,EAASD,EAAcsC,eAAe,CAACJ,EAAiBxB,KAAoB,EAAAyB,MAAMC,WAAWF,GAASG,KAAK3B,KAG1F,EAAA6B,QACrB,IAAItC,EAASD,EAAcuC,SAAS,CAAC9B,EAAgBC,KACnD,IAEE,OADyBjE,KAAKC,MAAMgE,GACtBgB,SAASjB,E,CACvB,MAAOtM,GACP,OAAO,C,KAIU,EAAAqO,SACrB,IAAIvC,EAASD,EAAcwC,UAAU,CAAC/B,EAAgBC,KACpD,IAEE,OADyBjE,KAAKC,MAAMgE,GACrBgB,SAASjB,E,CACxB,MAAOtM,GACP,OAAO,C,KAKU,EAAAsO,OACrB,IAAIxC,EAASD,EAAcyC,QAAQ,CAAChC,EAAgB5P,IAAwC,UAA1B4P,aAAM,EAANA,EAAQiC,iBAErD,EAAAC,QACrB,IAAI1C,EAASD,EAAc2C,SAAS,CAAClC,EAAgB5P,IAAwC,WAA1B4P,aAAM,EAANA,EAAQiC,iBAE/D,EAAAzB,IAAM,CAElBhB,EAASkB,SAAUlB,EAASmB,cAAenB,EAASoB,WAAYpB,EAASqB,gBAGzErB,EAASsB,MAAOtB,EAASuB,SAGzBvB,EAASwB,SAAUxB,EAAS0B,YAG5B1B,EAAS4B,WAAY5B,EAAS8B,SAG9B9B,EAASgC,WAAYhC,EAASqC,cAG9BrC,EAASsC,QAAStC,EAASuC,SAG3BvC,EAASwC,OAAQxC,EAAS0C,Q,uaC1J9B,gBAEA,UACA,UAEA,UAGA,8BAOE,WAAAjU,CAAYwE,GAFJ,KAAA0P,QAAkB,EAGxB,MAAM,OAACvV,EAAM,cAAEK,EAAa,iBAAEC,GAAoBuF,EAClDxG,KAAKW,OAASA,EACdX,KAAKgB,cAAgBA,EACrBhB,KAAKmW,WAAa,IAAI,EAAAC,kBAAkBnV,EAAkBjB,KAAKW,QAC/DX,KAAKqW,gBAAkB,IAAI,EAAAC,gBAAgB9P,EAAexG,KAAKmW,YAE/DnW,KAAKuW,WACP,CAEQ,SAAAA,GACFvW,KAAKkW,QAITtO,YAAW,IAAY,EAAD,gCACpB,UACQ5H,KAAK8K,O,CACX,MAAOE,GACPhL,KAAKW,OAAO4C,MAAM,6DAA8DyH,E,CAGlFhL,KAAKuW,WACP,KAAGvW,KAAKgB,cACV,CAEA,KAAA8J,GACE,MAAM0L,EAAa,IAAI,EAAAC,WAEvB,OADAzW,KAAK6K,OAAO2L,GACLA,EAAWE,mBACpB,CAEM,KAAApM,G,yCACJ,GAAItK,KAAKkW,OACP,OAIF,MAAMS,EAAW,IAAI,EAAAC,cACrB5W,KAAK6K,OAAO8L,GAEZ,UACQA,EAASD,mB,CACf,MAAO1L,GACPhL,KAAKW,OAAO4C,MAAM,6C,CAIpBvD,KAAKmW,WAAW7L,QAChBtK,KAAKkW,QAAS,CAChB,G,CAEA,MAAArL,CAAO2G,GACL,SAAI,IAAA/N,mBAAkB+N,KAIjBxR,KAAKmW,WAAWU,SAASrF,KACxBA,aAAiB,EAAAiF,YACnBjF,EAAMsF,WAGD,GAIX,E,2FC9EF,0BAIE,WAAA9U,CAA6B+U,EAAmCpW,GAAnC,KAAAoW,SAAAA,EAAmC,KAAApW,OAAAA,EAFxD,KAAAuV,QAAkB,EAGxBlW,KAAKgX,OAAS,EAChB,CAEA,QAAAH,CAASrF,GACP,OAAIxR,KAAKkW,SAILlW,KAAKgX,OAAO/S,QAAUjE,KAAK+W,UAC7B/W,KAAKW,OAAOyC,KAAK,wFACV,IAGTpD,KAAKgX,OAAOpU,KAAK4O,IACV,GACT,CAEA,KAAAyF,GACEjX,KAAKgX,OAAS,EAChB,CAEA,KAAAE,GACE,OAAOlX,KAAKgX,OAAOE,OACrB,CAEA,KAAA5M,GACEtK,KAAKkW,QAAS,CAChB,CAEA,kBAAIiB,GACF,MAAO,IAAInX,KAAKgX,OAClB,CAEA,UAAI/S,GACF,OAAOjE,KAAKgX,OAAO/S,MACrB,CAEA,WAAImT,GACF,OAAuB,IAAhBpX,KAAKiE,MACd,E,ofChDF,gBAEA,UAEA,UACA,aAEA,2BAOE,WAAAjC,CAAYwE,GACV,MAAM,OACJnG,EAAM,UACNI,EAAS,SACTmF,GACEY,GAEE,KAACpC,EAAI,SAAEoD,GAAY5B,EACzB5F,KAAKwQ,gBAAiB,IAAAA,gBAAenQ,EAAQ+D,GAC7CpE,KAAKS,UAAYA,EACjBT,KAAKwH,SAAWA,CAClB,CAEM,IAAA6P,CAAKrG,EAAiBsG,G,yCAC1B,MAAM1G,EAA0B,CAC9BnB,OAAQ,EAAA8H,eAAeC,WAGnBjH,EAAO,+BACRvQ,KAAKwQ,gBAAc,CACtB,eAAgB,qBAGlB,IAAIjN,EACJ,IACE,MAAM,OAACkM,SAAgBzP,KAAKwH,SAASqJ,MAAM7Q,KAAKS,UAAW,CACzD8P,UACAnB,KAAM4B,EACNE,OAAQ,SAGV,GAAIzB,GAAU,KAAOA,GAAU,IAC7B,OAAOmB,EAOT,GAJArN,EAAQ,IAAI,EAAAmP,yBACV,IAAA/C,kBAAiB,CAACF,SAAQ/K,QAAS,4BAA6B,oBAG7D,IAAAgL,mBAAkBD,GAGrB,OAFAmB,EAAInB,OAAS,EAAA8H,eAAeE,sBAC5B7G,EAAIrN,MAAQA,EACLqN,C,CAET,MAAO5F,GACPzH,EAAQyH,C,CAIV,OAAIzH,IAAU+T,GACZ1G,EAAInB,OAAS,EAAA8H,eAAexP,OAC5B6I,EAAIrN,MAAQA,EACLqN,UAIH,eAEC5Q,KAAKqX,KAAKrG,GAAS,GAC5B,G,oGCxEF,gBAEA,+BACE,SAAA0G,CAAUV,GACR,MAAMhG,EAAUgG,EACbhN,KAAIwH,GAASA,aAAiB,EAAA2B,WAAa3B,aAAiB,EAAA7G,YAAc6G,EAAMmG,YAAc,OAC9F/K,QAAO4E,GAAmB,OAAVA,IAEnB,OAAOzB,KAAKoB,UAAUH,EACxB,E,ifCRF,gBAEA,UACA,UACA,UAEA,UACA,aAEA,wBASE,WAAAhP,CAAYwE,EAA8BoR,GAHlC,KAAAC,mBAAqB,GACrB,KAAA/I,SAAmB,EAGzB,MAAM,OAACnO,EAAM,iBAAEM,GAAoBuF,EACnCxG,KAAKW,OAASA,EAEdX,KAAK8X,OAAS,IAAI,EAAA1B,kBAAkBnV,EAAkBjB,KAAKW,QAC3DX,KAAK+X,OAAS,IAAI,EAAAC,mBAAmBxR,GACrCxG,KAAKiY,WAAa,IAAI,EAAAC,uBAEtBlY,KAAKmY,aAAaP,GAAOvL,MAC3B,CAEc,YAAA8L,CAAaP,G,yCACzB5X,KAAKW,OAAOwN,MAAM,wBAElB,IAAIiK,GAAU,EACd,KAAOA,GACL,IACE,MAAM5G,EAAQoG,EAAMV,QAEpB,QAAcnV,IAAVyP,EAAqB,OACjB,aAAM,KACZ,Q,CAGEA,aAAiB,EAAA6G,aACnBrY,KAAKsY,iBAAiB9G,GACbA,aAAiB,EAAAiF,iBACpBzW,KAAKuY,aAAa/G,GACfA,aAAiB,EAAAoF,sBACpB5W,KAAKuY,aAAa/G,GACxBxR,KAAK8O,SAAU,EACfsJ,GAAU,E,CAEZ,MAAOpN,GACPhL,KAAKW,OAAO4C,MAAM,wCAAyCyH,E,CAI/DhL,KAAKW,OAAOwN,MAAM,wBACpB,G,CAEQ,gBAAAmK,CAAiB9G,GACnBxR,KAAK8O,UAIL9O,KAAK8X,OAAOjB,SAASrF,GACvBxR,KAAKW,OAAOwN,MAAM,0BAElBnO,KAAKW,OAAOyC,KAAK,qGAErB,CAEc,YAAAmV,CAAa/G,G,yCACzB,GAAIxR,KAAK8O,QAEP,YADA0C,EAAMsF,WAIR,GAAI9W,KAAK8X,OAAOV,QAKd,OAJA5F,EAAMsF,gBACN9W,KAAKW,OAAOwN,MAAM,uBAMpB,MAAMqK,EAAWxY,KAAK8X,OAAOX,eAC7BnX,KAAK8X,OAAOb,QACZ,UACQjX,KAAKyY,YAAYD,GACvBxY,KAAKW,OAAOwN,MAAM,GAAIqK,EAASvU,kC,CAC/B,MAAO+G,GACPhL,KAAKW,OAAOyC,KAAK,0CAA2C4H,E,CAG9DwG,EAAMsF,UACR,G,CAEc,WAAA2B,CAAYzB,G,yCAExB,MAAM0B,GADN1B,EAAShX,KAAK2Y,gBAAgB3B,IACT/S,OACrB,IAAK,IAAIlE,EAAI,EAAGA,EAAI2Y,EAAO3Y,GAAKC,KAAK6X,mBAAoB,CACvD,MAAM5T,EAASsL,KAAKxM,IAAI/C,KAAK6X,mBAAoBa,EAAQ3Y,GACnDiS,EAAQgF,EAAOhF,MAAMjS,EAAGA,EAAIkE,GAC5B+M,EAAUhR,KAAKiY,WAAWP,UAAU1F,IAEpC,OAACvC,SAAgBzP,KAAK+X,OAAOV,KAAKrG,GAAS,GAC7CvB,IAAW,EAAA8H,eAAeE,wBAC5BzX,KAAK8O,SAAU,E,CAGrB,G,CAEQ,eAAA6J,CAAgB3B,GACtB,MAAM4B,EAAyB,GACzBC,EAAmB,GAEzB,IAAK,MAAMrH,KAASwF,EACb6B,EAAO7D,SAASxD,EAAMsH,QACzBF,EAAahW,KAAK4O,GAClBqH,EAAOjW,KAAK4O,EAAMsH,OAItB,OAAOF,CACT,E,4MC9HF,IAAYrB,E,yEAAZ,SAAYA,GACV,6BACA,uBACA,oDACD,CAJD,CAAYA,IAAc,iBAAdA,EAAc,I,2FCG1B,2BACE,KAAAzM,GACE,OAAOzC,QAAQC,SACjB,CAEA,KAAAgC,GACE,OAAOjC,QAAQC,SACjB,CAEA,MAAAuC,CAAO2G,GACL,OAAO,CACT,E,0JCPF,MAAauH,EAKX,QAAID,GACF,OAAO9Y,KAAK+Q,UAAUuB,UACxB,CAEA,WAAAtQ,GANA,KAAA+O,WAAY,IAAK9B,MAAQ+J,UAOvBhZ,KAAKiZ,mBAAqB,IAAI5Q,SAAqBC,IACjDtI,KAAKkZ,UAAY5Q,CAAO,GAE5B,CAEA,iBAAAoO,GACE,OAAO1W,KAAKiZ,kBACd,CAEA,QAAAnC,G,MACgB,QAAd,EAAA9W,KAAKkZ,iBAAS,mBAAGlZ,KACnB,EArBF,eAwBA,2BAAgC+Y,IAGhC,8BAAmCA,IAGnC,MAAaV,EAAb,cACE,KAAAtH,WAAY,IAAK9B,MAAQ+J,SAQ3B,CANE,QAAIF,GACF,OAAO9Y,KAAK+Q,UAAUuB,UACxB,CAEA,SAAAqF,GACA,EARF,iBAWA,4BAAiCU,EAC/B,WAAArW,CACSR,EACAgJ,EACAI,EACAH,GAEPgI,QALO,KAAAjR,KAAAA,EACA,KAAAgJ,UAAAA,EACA,KAAAI,QAAAA,EACA,KAAAH,YAAAA,CAGT,CAEQ,WAAA0O,GACN,MAAO,CACLtU,MAAO7E,KAAKwB,KAAKqD,MACjBC,KAAM9E,KAAKwB,KAAKsD,KAChBM,qBAAsBpF,KAAKwB,KAAK4D,qBAEpC,CAEA,SAAAuS,GACE,MAAO,CACLnW,KAAMxB,KAAKmZ,cACXC,QAAS,CAAC,CACRC,MAAO,eACPtI,UAAW/Q,KAAK+Q,UAChBuI,aAActZ,KAAKyK,YACnBG,QAAS5K,KAAK4K,QACdJ,UAAWxK,KAAKwK,UAChB+O,KAAM,gBAGZ,CAEA,QAAIT,GACF,MAAM9H,EAAUhR,KAAK2X,YACf6B,EAAY,CAChBhY,KAAMwP,EAAQxP,KACd4X,QAASpI,EAAQoI,QAAQpP,KAAKyP,GAAY,OAAD,wBAAKA,GAAC,CAAE1I,eAAWhP,OAE9D,OAAOgO,KAAKoB,UAAUqI,EACxB,GAGF,0BAA+BnB,EAC7B,WAAArW,CACSR,EACAyI,EACAR,EACA2J,GAEPX,QALO,KAAAjR,KAAAA,EACA,KAAAyI,QAAAA,EACA,KAAAR,UAAAA,EACA,KAAA2J,iBAAAA,CAGT,CAEQ,WAAA+F,GACN,MAAO,CACLtU,MAAO7E,KAAKwB,KAAKqD,MACjBC,KAAM9E,KAAKwB,KAAKsD,KAChBM,qBAAsBpF,KAAKwB,KAAK4D,qBAEpC,CAEA,SAAAuS,GACE,MAAO,CACLnW,KAAMxB,KAAKmZ,cACXlG,WAAY,CAAC,CACXyG,eAAgB1Z,KAAKiK,QACrBmJ,iBAAkBpT,KAAKoT,iBACvBrC,UAAW/Q,KAAK+Q,UAChBtH,UAAWzJ,KAAKyJ,YAGtB,CAEA,QAAIqP,GACF,MAAM9H,EAAUhR,KAAK2X,YACf6B,EAAY,CAChBhY,KAAMwP,EAAQxP,KACdyR,WAAYjC,EAAQiC,WAAWjJ,KAAKyP,GAAY,OAAD,wBAAKA,GAAC,CAAE1I,eAAWhP,OAGpE,OAAOgO,KAAKoB,UAAUqI,EACxB,E,4fChIF,aACA,aACA,aACA,aACA,aACA,aACA,aACA,aACA,aACA,aACA,W,4fCVA,aACA,aACA,aACA,aACA,aACA,aACA,aACA,aACA,aACA,aAEA,aACA,aACA,aACA,aACA,WACA,aACA,aACA,YACA,W,iLCnBA,mBAIMG,EAAc,CAClBxL,MAAO,EACP/J,KAAM,EACNhB,KAAM,EACNG,MAAO,EACPqW,KAAM,GAGFC,EAAa,CAAC,QAAS,OAAQ,OAAQ,QAAS,QAatD,MAAaC,EAcX,UAAO7M,GACL,OAAO,IAAI6M,EAAY,CAAC,EAC1B,CAEA,WAAA9X,CAAYF,G,UACV9B,KAAK+Z,SAA+C,QAApC,EAAAJ,EAAyB,QAAb,EAAA7X,EAAQkY,aAAK,QAAI,eAAO,QAAIL,EAAYvV,KACpEpE,KAAK8E,KAAmB,QAAZ,EAAAhD,EAAQgD,YAAI,QAAI,UAE5B9E,KAAKia,YAAcnY,EAAQmY,YAC3Bja,KAAKka,UAAYpY,EAAQoY,SAC3B,CAEQ,SAAAC,IAAaC,G,MACnB,IACE,OAAIpa,KAAKka,UAEc,QAAd,EAAAla,KAAKka,iBAAS,4BAAME,IAEtB,gBAAUA,E,CACjB,SACA,OAAO,gBAAUA,E,CAErB,CAEQ,QAAAC,CAASvS,GACf,IACE9H,KAAKia,YAAanS,E,CAClB,SAEAwS,QAAQ/W,MAAMuE,E,CAElB,CAEQ,GAAAyS,CAAIP,EAAeI,GACzB,GAAIJ,GAASha,KAAK+Z,SAAU,CAC1B,MAAMS,EAAS,GAAIX,EAAWG,QAAcha,KAAK8E,QACjD,IACM9E,KAAKia,YACPja,KAAKqa,SAAS,GAAIG,KAAYxa,KAAKma,aAAaC,MAKhDE,QAAQ/W,SAAS6W,E,CAEnB,SAGAE,QAAQ/W,SAAS6W,E,EAGvB,CAEA,KAAA7W,IAAS6W,GACPpa,KAAKua,IAAIZ,EAAYpW,MAAO6W,EAC9B,CAEA,IAAAhX,IAAQgX,GACNpa,KAAKua,IAAIZ,EAAYvW,KAAMgX,EAC7B,CAEA,IAAAhW,IAAQgW,GACNpa,KAAKua,IAAIZ,EAAYvV,KAAMgW,EAC7B,CAEA,KAAAjM,IAASiM,GACPpa,KAAKua,IAAIZ,EAAYxL,MAAOiM,EAC9B,EAjFF,e,+PCxBA,gBAEMK,EAAqB,CACzBlX,MAAO,EAAApD,eAAekE,SACtBjB,KAAM,EAAAjD,eAAekE,SACrBD,KAAM,EAAAjE,eAAekE,SACrB8J,MAAO,EAAAhO,eAAekE,UAaxB,gBAWE,WAAArC,CAAYrB,EAAiB+Z,GAC3B9Z,OAAO6M,QAAQgN,GAAoBnY,SAAQ,EAAE0X,EAAOvX,MAClD,IAAKA,EAAUC,GAAI/B,EAAeqZ,IAChC,MAAM,IAAI1T,MAAM,gDAAiD0T,gB,IAOrEha,KAAKW,OAASA,EACdX,KAAK0a,SAAWA,CAClB,CAEQ,GAAAH,CAAIP,EAA4CI,GACtD,IACEpa,KAAKW,OAAOqZ,MAAUI,E,CACtB,SAEApa,KAAK0a,SAASV,MAAUI,E,CAE5B,CAEA,KAAA7W,IAAS6W,GACPpa,KAAKua,IAAI,QAASH,EACpB,CAEA,IAAAhX,IAAQgX,GACNpa,KAAKua,IAAI,OAAQH,EACnB,CAEA,IAAAhW,IAAQgW,GACNpa,KAAKua,IAAI,OAAQH,EACnB,CAEA,KAAAjM,IAASiM,GACPpa,KAAKua,IAAI,QAASH,EACpB,E,kECpEF,gBAWA,SAASO,EAAa7H,GACpB,GAAmB,iBAARA,EACT,OAAOA,EAET,QAAY/Q,IAAR+Q,EACF,MAAO,YAET,GAAY,OAARA,EACF,MAAO,OAET,GAAIlS,OAAOga,UAAUC,eAAeC,KAAKhI,EAAK,YAC5C,IACE,OAAOA,EAAIR,U,CACX,S,CAKJ,GAAmB,iBAARQ,EACT,MAAO,GAAIA,KAEb,IACE,OAAO/C,KAAKoB,UAAU2B,E,CACtB,MAAOvP,GACP,OAAIA,aAAiBwX,WAAaxX,EAAMmB,QAAQsW,QAAQ,aAAe,EAC9D,aAEF,qB,CAEX,CAqDA,MAAMC,EAAgD,CACpDlJ,EAAIe,GAAa6H,EAAa7H,GAC9BoI,EAAIpI,GA/CN,SAAkBA,GAGhB,MAAmB,iBAARA,EACF,MAEU,iBAARA,EACF,GAAIA,KAENxS,OAAOF,OAAO0S,GACvB,CAqCmBqI,CAASrI,GAC1B/S,EAAI+S,GA9BN,SAAeA,GACb,MAAmB,iBAARA,EACF,MAEU,iBAARA,EACF,GAAIA,KAENxS,OAAO8a,SAAStI,EAAK,IAC9B,CAsBmBuI,CAAMvI,GACvBwI,EAAIxI,GAfN,SAAiBA,GACf,MAAmB,iBAARA,EACF,MAEFxS,OAAO4T,WAAWpB,GAC3B,CAUmByI,CAAQzI,GACzB0I,EAAI1I,GAAa6H,EAAa7H,GAC9B0B,EAAI1B,GAAa6H,EAAa7H,GAC9B2I,EAAI3I,GAAa6H,EAAa7H,GAC9B4I,EAAG,IAAM,IAaX,sBAAkCtB,G,MAChC,MAAMuB,EAAevB,EAAKlD,QAC1B,GAAI,EAAA/W,eAAeG,OAAOoC,GAAGiZ,GAAe,CAC1C,IAAIC,EAAM,GACN7b,EAAI,EACR,KAAOA,EAAI4b,EAAa1X,QAAQ,CAC9B,MAAM4X,EAAOF,EAAaG,OAAO/b,GACjC,GAAa,MAAT8b,GAEF,GADkB9b,EAAI,EACN4b,EAAa1X,OAAQ,CACnC,MAAM8X,EAAWJ,EAAaG,OAAO/b,EAAI,GACzC,GAAIgc,KAAYd,GAAWb,EAAKnW,OAAQ,CACtC,MAAMiB,EAAQkV,EAAKlD,QAGnB0E,GAAwB,QAAjB,EAAAX,EAAQc,UAAS,sBAAG7W,E,MAE3B0W,GADsB,MAAbG,EACF,IAEA,IAAKA,IAEdhc,GAAK,C,OAGP6b,GAAOC,EACP9b,GAAK,C,CAWT,OANIqa,EAAKnW,SACH2X,EAAI3X,SACN2X,GAAO,KAETA,GAAOxB,EAAKpQ,IAAI2Q,GAAcxI,KAAK,MAE9ByJ,C,CAET,OAAOxB,EAAKpQ,IAAI2Q,GAAcxI,KAAK,IACrC,C,4fCzJA,aACA,aACA,aACA,aACA,aACA,Y,gECIA,gBASE,WAAAnQ,CACkB3B,EAChB2b,EASgBpW,GAVA,KAAAvF,OAAAA,EAUA,KAAAuF,SAAAA,EAEhB5F,KAAKW,OAASqb,EAAcrb,OAC5BX,KAAKmB,QAAU6a,EAAc7a,QAC7BnB,KAAKgB,cAAgBgb,EAAchb,cACnChB,KAAKiB,iBAAmB+a,EAAc/a,iBACtCjB,KAAKQ,aAAewb,EAAcxb,aAClCR,KAAKO,WAAayb,EAAczb,WAChCP,KAAKS,UAAYub,EAAcvb,SACjC,E,4TCnCF,gBACE,yBAAOuC,CAAmB8B,EAAcI,EAAenC,GACrD,MAAO,kBAAmB+B,2BAAgCI,uBAA6BnC,WACzF,CAEA,oBAAOM,CAAcyB,GACnB,MAAO,mCAAoCA,IAC7C,CAEA,sBAAO3B,CAAgB2B,EAAcmX,EAAsBC,GACzD,MAAO,kBAAmBpX,wBAA6BmX,UAAuBC,wBAChF,CAEA,6BAAOrZ,CAAuBiC,EAAcoX,GAC1C,MAAO,kBAAmBpX,+BAAoCoX,0BAChE,CAEA,sBAAOrY,CAAgBiB,GACrB,MAAO,mDAAoDA,0CAC7D,CAEA,gBAAOqX,CAAUrX,GACf,MAAO,GAAIA,gBACb,CAEA,yBAAOsX,CAAmBtX,GACxB,MAAO,yBAA0BA,GACnC,CAEA,iCAAOuX,CAA2B3T,GAChC,MAAO,gBAAiBA,uBAC1B,E,oFCzBF,oBAKE,WAAA1G,CAAY6C,GAJJ,KAAAyX,OAAiB,GACjB,KAAAC,MAAgB,GAChB,KAAAC,QAA8B,GAGpCxc,KAAKsc,OAASzX,CAChB,CAEA,IAAAC,CAAKA,GAEH,OADA9E,KAAKuc,MAAQzX,EACN9E,IACT,CAEA,MAAAyc,CAAOC,EAAsBxX,G,MAE3B,OADY,QAAZ,EAAAlF,KAAKwc,eAAO,SAAE5Z,KAAK,CAAEkC,KAAM4X,EAAcxX,MAAOA,IACzClF,IACT,CAEA,KAAAwF,GACE,MAAO,CACLV,KAAM9E,KAAKuc,MACX1X,MAAO7E,KAAKsc,OACZlX,qBAAsBpF,KAAKwc,QAE/B,E,uWCxBF,mBAkBA,MAAaG,EACX,EAAAja,CAAGka,GACD,GAAIC,MAAMC,QAAQF,GAChB,OAAO,EAET,MACMG,SADaH,EAEnB,MAAyB,aAAlBG,GAAkD,WAAlBA,CACzC,CAEA,OAAApa,GACE,MAAO,0BACT,EAZF,sBAkBA,MAAaqa,EAKX,WAAAhb,CAAYib,EAAkBC,GAC5Bld,KAAKid,SAAWA,EAChBjd,KAAKmd,cAAgBD,CACvB,CAEA,EAAAxa,CAAG0a,GACD,OAAIP,MAAMC,QAAQM,WAGJA,IAAMpd,KAAKmd,MAC3B,CAEA,OAAAxa,GACE,OAAO3C,KAAKid,QACd,EAnBF,SA4BA,MAAaI,EAKX,WAAArb,CAAYib,EAAkBC,GAC5Bld,KAAKid,SAAWA,EAChBjd,KAAKmd,cAAgBD,CACvB,CAEA,EAAAxa,CAAG0a,GACD,QAAIP,MAAMC,QAAQM,OACZA,EAAEnZ,OAAS,IACNmZ,EAAEE,OAAOxK,UAAeA,IAAQ9S,KAAKmd,SAKlD,CAEA,OAAAxa,GACE,OAAO3C,KAAKid,QACd,EAtBF,cA4BA,MAAana,UAA0Bka,EAGrC,WAAAhb,CAAYe,GACV0P,MAAM,gCAAiC1P,IAAQ,GAC/C/C,KAAK+C,IAAMA,CACb,CAES,EAAAL,CAAG0a,GACV,cAAcA,IAAMpd,KAAKmd,QAAWC,GAAgBpd,KAAK+C,GAC3D,EAVF,sBAgBA,MAAawa,UAA4BP,EAGvC,WAAAhb,CAAYwb,GACV/K,MAAM,mBAAoB+K,IAAe,IACzCxd,KAAKwd,WAAaA,CACpB,CAES,EAAA9a,CAAG0a,GACV,QAAUA,EAAaK,MAAMzd,KAAKwd,WACpC,EAVF,wBAgBA,MAAanZ,EACX,EAAA3B,CAAG0a,GAKD,MAAoB,mBAANA,CAChB,CAEA,OAAAza,GACE,MAAO,UACT,EAXF,aAcA,MAAa+a,EACX,EAAAhb,CAAG0a,GACD,MAAoB,kBAANA,GAAP,MAAiCA,CAC1C,CAEA,OAAAza,GACE,MAAO,4BACT,EAPF,oBAUA,yCACE,KAAAO,SAAqB,EAqCvB,CAnCE,EAAAR,CAAG0a,GACD,GAAiB,iBAANA,GAAwB,OAANA,EAE3B,OADApd,KAAKkD,SAASN,KAAK,UAAewZ,mBAAmB,eAC9C,EAGT,IACE,MAAM9a,EAAY8b,EAClB,IAAK,IAAI5R,KAAQlK,EAAW,CACD,CAAC,KAAM,aAAagc,OAAO5U,GAAQ9H,OAAOyB,KAAKmJ,GAAMwJ,SAAStM,KAAvF,MACMrG,EAAOzB,OAAOyB,KAAKmJ,GAUzB,GARInJ,EAAK2S,SAAS,OAChBhV,KAAKkD,SAASN,KAAK,UAAeyZ,2BAA2B,OAG3Dha,EAAK2S,SAAS,cAChBhV,KAAKkD,SAASN,KAAK,UAAeyZ,2BAA2B,cAG3Drc,KAAKkD,SAASe,OAAS,EACzB,OAAO,C,EAGX,MAAOE,GAEP,OADAnE,KAAKkD,SAASN,KAAK,UAAeO,gBAAgB,YAAanD,KAAK2C,iBAAkBya,KAC/E,C,CAGT,OAAO,CACT,CAEA,OAAAza,GACE,MAAO,aACT,GAGF,oCACE,KAAAO,SAAqB,EA0BvB,CAxBE,EAAAR,CAAG0a,GACD,GAAiB,iBAANA,GAAwB,OAANA,EAE3B,OADApd,KAAKkD,SAASN,KAAK,UAAeuZ,UAAU,UACrC,EAGT,MAAM3a,EAAO4b,EAEb,MAA0B,iBAAf5b,EAAKqD,OAA4C,KAAtBrD,EAAKqD,MAAME,QAC/C/E,KAAKkD,SAASN,KAAK,UAAeuZ,UAAU,gBACrC,GAGgB,iBAAd3a,EAAKsD,MAA0C,KAArBtD,EAAKsD,KAAKC,SAC7C/E,KAAKkD,SAASN,KAAK,UAAeuZ,UAAU,eACrC,EAIX,CAEA,OAAAxZ,GACE,MAAO,MACT,GASF,MAAMgb,EAAa,mEAMnB,MAAaC,EACX,EAAAlb,CAAG0a,GACD,MAAoB,iBAANA,GAAgC,iBAANA,GAAkBO,EAAWhI,KAAKyH,EAC5E,CAEA,OAAAza,GACE,MAAO,MACT,EAPF,kBAaA,MAAakb,UAAsBN,EACjC,WAAAvb,GACEyQ,MAAM,eACR,CAES,EAAA/P,CAAG0a,GACV,OAAO3K,MAAM/P,GAAG0a,IAAY,SAANA,CACxB,EAPF,kBAaA,MAAajd,EAmBX,sBAAO2d,CAAmBb,EAAkBC,GAC1C,OAAO,IAAIG,EAAaJ,EAAUC,EACpC,CAEA,oBAAOa,CAAchb,GACnB,OAAO,IAAID,EAAkBC,EAC/B,CAEA,0BAAOib,CAAoBR,GACzB,OAAO,IAAID,EAAoBC,EACjC,EA7BF,mBACkB,EAAAld,OAAS,IAAI0c,EAAa,SAAU,IAEpC,EAAA5c,OAAS,IAAI4c,EAAa,SAAU,GAEpC,EAAAlc,gBAAkB,IAAI6b,EAEtB,EAAA/b,OAAS,IAAIoc,EAAa,SAAU,CAAC,GAErC,EAAAiB,YAAc,IAAIZ,EAAkB,WAAY,IAEhD,EAAAjc,QAAU,IAAI4b,EAAc,WAAW,GAEvC,EAAAvb,KAAO,IAAIub,EAAa,SAAU,CAAC,GAEnC,EAAAzb,UAAY,IAAIyb,EAAa,SAAU,CAAC,GAExC,EAAA3Y,SAAW,IAAIA,EAcf,EAAA4K,KAAO,IAAI2O,EAEX,EAAAM,KAAO,IAAIL,EACX,EAAAH,gBAAkB,IAAIA,C,4fC3SxC,aACA,aACA,aACA,aACA,aACA,aACA,YACA,Y,+PCNA,gBAGA,gBACE,WAAI9S,GACF,MAAO,oBACT,CAEA,YAAAuT,GACE,MAAO,CACLC,GAAI,CAAC,EACLtZ,KAAM,UACNuZ,WAAY,CAAC,EAEjB,CAEA,OAAAC,GACE,MAAO,CACLxZ,KAAM,EAAAA,KACNyC,QAAS,EAAAA,QACTgX,cAAeve,KAAK4K,QAExB,E,4JCnBF,mBACA,YAEA,aAEA,gBAME,WAAA5I,CAAYF,GALZ,KAAAsC,KAAc,IAAI,UAMhBpE,KAAKwH,SAAW,IAAI,UACpBxH,KAAKsH,UAAY,IAAI,SACvB,E,+DChBF,gBACE,KAAAuJ,CAAM2N,EAAa1c,EAA2B,CAAC,GAC7C,OAAO+O,MAAM2N,EAAK1c,EACpB,E,kECJF,gBAEA,UACA,UACA,UAGM2c,EAA4B,CAAC,IAAM,IAAM,IAAM,IAAM,KAAO,KAAO,IAAO,KAsIhF,WAAe,IAAAC,OApIf,MAQE,WAAA1c,GALQ,KAAA2c,aAAe,EACf,KAAAzI,QAAkB,EAElB,KAAA0I,QAA4B,CAAC,EAGnC5e,KAAK6e,QAAU,IAAI,EAAAC,YACrB,CAEA,QAAArY,CAASjF,GACPxB,KAAK4e,QAAQpd,KAAOA,EACpBxB,KAAK+e,YACP,CAEA,OAAArN,G,YACE,IAAIsN,EAAOhf,KACX,MAAMgP,EAAYC,KAAKC,MACjBsP,EAAMxe,KAAK4e,QAAQpe,aAAa4R,QAAQ,QAAS,MAAQ,uBAAuB,IAAA6M,yBAAwBjf,KAAK4e,QAAQve,UAC3HL,KAAKkf,GAAK,IAAIC,UAAUX,GAGjB,QAAP,EAAAQ,EAAKE,UAAE,SAAEE,iBAAiB,QAAQ,SAA2B5N,GAE3DwN,EAAKJ,QAAQje,OAAOyD,KAAK,oDAAqD6K,KAAKC,MAAQF,QAC3FgQ,EAAKD,aACLC,EAAKK,iBACP,IAGO,QAAP,EAAAL,EAAKE,UAAE,SAAEE,iBAAiB,SAAS,SAAU5N,GAC3CwN,EAAKJ,QAAQje,OAAOyC,KAAK,oBACN,OAAfoO,EAAMjG,MAIVyT,EAAKM,WACP,IAGO,QAAP,EAAAN,EAAKE,UAAE,SAAEE,iBAAiB,SAAS,SAAU5N,GAE3CwN,EAAKJ,QAAQje,OAAOwN,MAAM,QAC5B,IAGO,QAAP,EAAA6Q,EAAKE,UAAE,SAAEE,iBAAiB,WAAW,SAAU5N,GAC7C,MAAM9M,EAAUqL,KAAKC,MAAMwB,EAAM7F,MACjC,GAA4B,cAAxBjH,EAAQuL,YACV,OAAQvL,EAAQiH,KAAKuE,WACnB,KAAK,EAAAC,wBAAwB9I,MAC3B2X,EAAKH,QAAQU,KAAK,QAAS7a,GAC3B,MACF,KAAK,EAAAyL,wBAAwBC,KAC3B4O,EAAKH,QAAQU,KAAK,MAAO7a,GAIjC,GACF,CAEA,KAAA4F,G,MACEtK,KAAKkW,QAAS,EACP,QAAP,EAAAlW,KAAKkf,UAAE,SAAE5U,MAAM,KAAM,gCACrBtK,KAAKkf,QAAKnd,CACZ,CAEA,MAAAsE,CAAOyL,GACDA,EAAM+M,UACR7e,KAAK6e,QAAU/M,EAAM+M,SAGvB7e,KAAK4e,QAAU,OAAH,UAAO9M,EACrB,CAEQ,eAAAuN,GACN,MAAMrO,EAAU,CACdf,YAAa,OACbtE,KAAM,MAGR/D,YAAW,K,MACT,KACa,QAAP,EAAA5H,KAAKkf,UAAE,eAAEM,cAAeL,UAAUM,MACpCzf,KAAK4e,QAAQje,OAAOwN,MAAM,gBAC1BnO,KAAKkf,GAAG7H,KAAKtH,KAAKoB,UAAUH,IAC5BhR,KAAKqf,mBAELrf,KAAK4e,QAAQje,OAAOwN,MAAM,oBAAqB,IAAIc,O,CAErD,MAAOjE,GACPhL,KAAK4e,QAAQje,OAAOwN,MAAMnD,E,IAE3BhL,KAAK4e,QAAQtN,aAClB,CAEQ,UAAAyN,G,QACN,MAAM/N,EAAU,CACdf,YAAa,YACbtE,KAAM,CACJoF,UAAW/Q,KAAK4e,QAAQhQ,oBACxBpN,KAAMxB,KAAK4e,QAAQpd,OAIvB,KACa,QAAP,EAAAxB,KAAKkf,UAAE,eAAEM,cAAeL,UAAUM,MACpCzf,KAAK4e,QAAQje,OAAOwN,MAAM,mBACnB,QAAP,EAAAnO,KAAKkf,UAAE,SAAE7H,KAAKtH,KAAKoB,UAAUH,KAE7BhR,KAAK4e,QAAQje,OAAO4C,MAAM,8C,CAE5B,MAAOyH,GACPhL,KAAK4e,QAAQje,OAAOwN,MAAMnD,E,CAE9B,CAEQ,SAAAsU,GACN,IAAKtf,KAAKkW,OAAQ,CAChBlW,KAAKkf,QAAKnd,EACV,MAAM2d,EAAWjB,EAA0BlP,KAAKxM,IAAI/C,KAAK2e,eAAgBF,EAA0Bxa,OAAS,IAC5GjE,KAAK4e,QAAQje,OAAOyD,KAAK,uCAAwCsb,mBACjE9X,YAAW,KACT5H,KAAK4e,QAAQje,OAAOyD,KAAK,0GAA2Gsb,kBACpI1f,KAAK0R,SAAS,GACbgO,E,CAEP,G,4JC3IF,gBAEA,UACA,UACA,aACA,UAEA,aAKA,MAAMC,UAAiB,EAAAC,aAGrB,WAAA5d,CAAYF,GACV,MAAM+d,EAAiB,IAAI,EAAA/F,YAAY,CACrCE,MAAO,OACPC,YAAaK,QAAQC,MAGjB5Z,EAASmB,EAAQnB,OAAS,IAAI,UAAWmB,EAAQnB,OAAQkf,GAAkBA,EAE3EhB,EAAU,IAAI,EAAAC,aAAane,GAEjC8R,MAAM,OAAD,wBACC3Q,GAAO,CAAEnB,WACb,IAAI,UAAgB,OAAD,wBAAKmB,GAAO,CAAEnB,YACjC,CACEqF,QAAUgF,IACJ6T,EAAQiB,cAAc,UACxBjB,EAAQU,KAAK,QAASvU,E,EAG1B/E,SAAW+E,IACT6T,EAAQU,KAAK,SAAUvU,EAAI,EAE7B9E,QAAS,KACP2Y,EAAQU,KAAK,QAAQ,EAEvBpZ,SAAW9D,IACTwc,EAAQU,KAAK,SAAU,CAACld,IACxBA,EAAKC,SAASoG,GAAQmW,EAAQU,KAAK,UAAW7W,IAAQA,IAAK,EAE7DtC,kBAAmB,IACjByY,EACGkB,aACAC,MACElb,GACU,WAATA,GAAsC,iBAATA,GAAqBA,EAAKsQ,WAAW,eAK9EpV,KAAK6e,QAAUA,CACjB,EAGF,WAAe,IAAAH,OAAMiB,E,kECzDrB,eAYA,UAEA,gBASE,WAAA3d,CAAYF,GARJ,KAAAjB,MAA4B,CAAC,EAE7B,KAAAof,YAAa,EAEb,KAAAhb,MAAe,CAAC,EAKtBjF,KAAKW,OAASmB,EAAQnB,MACxB,CAEA,QAAA8F,CAASjF,GACPxB,KAAKiF,MAAQ,OAAH,UAAOzD,GAEjB0e,aAAaC,QAAQ,EAAAC,uBAAuB,IAAAC,eAAcrgB,KAAKiF,QAC/DjF,KAAKsgB,sBACP,CAEA,QAAI9e,GACF,OAAOxB,KAAKiF,KACd,CAEQ,OAAAsb,CAAQnW,EAAiB1B,EAAa6F,GAC5C,IAAIjB,EAAQtN,KAAKa,MAAMuJ,EAAKoC,WAK5B,GAJKc,IACHA,EAAQ,CAAC,EACTtN,KAAKa,MAAMuJ,EAAKoC,WAAac,GAE3B1M,OAAOia,eAAeC,KAAKxN,EAAO5E,GAAM,CAC1C,MAAM8X,EAAMlT,EAAM5E,KACb8X,GAAOA,EAAIjZ,QAAUgH,EAAKhH,WAC7B+F,EAAM5E,GAAO6F,E,MAGfjB,EAAM5E,GAAO6F,EAGXA,EAAKhH,QAAUvH,KAAKa,MAAM0G,UAC5BvH,KAAKa,MAAM0G,QAAUgH,EAAKhH,SAG5BvH,KAAKygB,oBACP,CAEA,GAAAxT,CAAI7C,EAAiB1B,GACnB,MAAM4E,EAAQtN,KAAKa,MAAMuJ,EAAKoC,WAC9B,GAAIc,GACE1M,OAAOga,UAAUC,eAAeC,KAAKxN,EAAO5E,GAAM,CACpD,MAAM6F,EAAOjB,EAAM5E,GACnB,GAAI6F,EACF,OAAOA,C,CAIb,OAAO,IACT,CAEA,GAAA1E,CAAIO,G,MACF,MAAML,EAAyB,CAAC,EAC1BuD,EAAkC,QAA1B,EAAAtN,KAAKa,MAAMuJ,EAAKoC,kBAAU,QAAI,CAAC,EAO7C,OANA5L,OAAO6M,QAAQH,GAAOhL,SAAQ,EAAEoG,EAAK6F,MAC/BA,IACFxE,EAAOrB,GAAmB6F,E,IAIvB,CAACxE,EAAQ/J,KAAKa,MAAM0G,QAC7B,CAEA,IAAAhB,CAAK0F,EAA4BlB,GAC/B/K,KAAKa,MAAQoL,EAEbrL,OAAOyB,KAAK4J,GAASjC,KAAIwC,IACvB5L,OAAO6M,QAAQxB,EAAQO,IAAYlK,SAAQ,EAAE6B,EAAGoK,MAC9C,MAAMmS,EAAMnS,EACRmS,EAAInZ,QAAUvH,KAAKa,MAAM0G,UAC3BvH,KAAKa,MAAM0G,QAAUmZ,EAAInZ,Q,GAE3B,IAGJvH,KAAKygB,qBACLzgB,KAAKigB,YAAa,EAClBlV,SAAAA,GACF,CAEA,MAAA+B,CAAO1C,EAAiBuB,EAAuBZ,GAC7C/K,KAAKugB,QAAQnW,EAAMuB,EAAKjD,IAAKiD,GAC7BZ,SAAAA,GACF,CAEA,WAAAlD,GACE,OAAO7H,KAAKigB,UACd,CAGA,KAAA3V,GAEA,CAEA,cAAAqW,GACE,MAAO,qBACT,CAEA,WAAIpZ,GACF,OAAOvH,KAAKa,MAAM0G,OACpB,CAEQ,kBAAAkZ,GACN,MAAMG,EAAa,GAAG,EAAAC,mBAAmB7gB,KAAKiF,MAAMJ,QACpDqb,aAAaC,QAAQS,EAAY7Q,KAAKoB,UAAUnR,KAAKa,OACvD,CAEQ,oBAAAyf,GACN,MAAMM,EAAa,GAAG,EAAAC,mBAAmB7gB,KAAKiF,MAAMJ,QAC9Cic,EAAeZ,aAAaa,QAAQH,GAC1C,IAAI/f,EAAkC,KAEtC,IACMigB,GAAgBA,EAAa/b,OAAOd,OAAS,IAC/CpD,EAAQkP,KAAKC,MAAM8Q,G,CAErB,MAAO9V,GACPhL,KAAKW,OAAO4C,MAAM,yCAAyCqd,IAAc5V,E,CAIzEhL,KAAKa,MADDA,GAGS,CACX6E,MAAO,CAAC,EACR6B,QAAS,EAGf,E,4fCvJF,aACA,aACA,aACA,Y,+HCDA,MAAqByZ,GACH,EAAAlX,MAAmB,CACjC0C,UAAW,S,UAFMwU,C,gICDrB,eAKA,gBAUE,WAAAhf,CAAYF,GARJ,KAAAmf,UAAkE,CAAC,EAEnE,KAAApgB,MAA4B,CAAC,EAE7B,KAAAof,YAAa,EAEb,KAAAhb,MAAe,CAAC,CAEQ,CAEhC,QAAAwB,CAASjF,G,MACPxB,KAAKiF,MAAQ,OAAH,UAAOzD,GAEjBxB,KAAKa,MAAgE,QAAxD,EAAAb,KAAKihB,UAAU,GAAG,EAAAJ,mBAAmB7gB,KAAKiF,MAAMJ,gBAAQ,QAAI,CAAEa,MAAO,CAAC,EAAG6B,QAAS,EACjG,CAEA,QAAI/F,GACF,OAAOxB,KAAKiF,KACd,CAEQ,OAAAsb,CAAQnW,EAAiB1B,EAAa6F,GAC5C,IAAIjB,EAAQtN,KAAKa,MAAMuJ,EAAKoC,WAK5B,GAJKc,IACHA,EAAQ,CAAC,EACTtN,KAAKa,MAAMuJ,EAAKoC,WAAac,GAE3B1M,OAAOia,eAAeC,KAAKxN,EAAO5E,GAAM,CAC1C,MAAM8X,EAAMlT,EAAM5E,KACb8X,GAAOA,EAAIjZ,QAAUgH,EAAKhH,WAC7B+F,EAAM5E,GAAO6F,E,MAGfjB,EAAM5E,GAAO6F,EAGXA,EAAKhH,QAAUvH,KAAKa,MAAM0G,UAC5BvH,KAAKa,MAAM0G,QAAUgH,EAAKhH,SAG5BvH,KAAKihB,UAAU,GAAG,EAAAJ,mBAAmB7gB,KAAKiF,MAAMJ,SAAW,OAAH,UAAO7E,KAAKa,MACtE,CAEA,GAAAoM,CAAI7C,EAAiB1B,GACnB,MAAM4E,EAAQtN,KAAKa,MAAMuJ,EAAKoC,WAC9B,GAAIc,GACE1M,OAAOga,UAAUC,eAAeC,KAAKxN,EAAO5E,GAAM,CACpD,MAAM6F,EAAOjB,EAAM5E,GACnB,GAAI6F,EACF,OAAOA,C,CAIb,OAAO,IACT,CAEA,GAAA1E,CAAIO,G,MACF,MAAML,EAAyB,CAAC,EAC1BuD,EAAkC,QAA1B,EAAAtN,KAAKa,MAAMuJ,EAAKoC,kBAAU,QAAI,CAAC,EAO7C,OANA5L,OAAO6M,QAAQH,GAAOhL,SAAQ,EAAEoG,EAAK6F,MAC/BA,IACFxE,EAAOrB,GAAmB6F,E,IAIvB,CAACxE,EAAQ/J,KAAKa,MAAM0G,QAC7B,CAEA,IAAAhB,CAAK0F,EAA4BlB,GAC/B/K,KAAKa,MAAQoL,EAEbjM,KAAKa,MAAM0G,QAAU,EACrB3G,OAAOyB,KAAK4J,GAASjC,KAAIwC,IACvB5L,OAAO6M,QAAQxB,EAAQO,IAAYlK,SAAQ,EAAE6B,EAAGoK,MAC9C,MAAMmS,EAAMnS,EACRmS,EAAInZ,QAAUvH,KAAKa,MAAM0G,UAC3BvH,KAAKa,MAAM0G,QAAUmZ,EAAInZ,Q,GAE3B,IAGJvH,KAAKihB,UAAU,GAAG,EAAAJ,mBAAmB7gB,KAAKiF,MAAMJ,SAAW,OAAH,UAAO7E,KAAKa,OACpEb,KAAKigB,YAAa,EAClBlV,SAAAA,GACF,CAEA,MAAA+B,CAAO1C,EAAiBuB,EAAuBZ,GAC7C/K,KAAKugB,QAAQnW,EAAMuB,EAAKjD,IAAKiD,GAC7BZ,SAAAA,GACF,CAEA,WAAAlD,GACE,OAAO7H,KAAKigB,UACd,CAGA,KAAA3V,GAEA,CAEA,cAAAqW,GACE,MAAO,iBACT,CAEA,WAAIpZ,GACF,OAAOvH,KAAKa,MAAM0G,OACpB,E,4fCjHF,aACA,YACA,aACA,aACA,W,uMCHA,mBAkBA,0BAA+B7B,GAC7B,MAAMqE,EAAS,CACb,CAAC,UAAUD,MAAM0C,WAAY,CAAC,GAUhC,OAPI9G,aAAK,EAALA,EAAOzB,UACT8F,EAAO,UAAUD,MAAM0C,WAAa9G,EAAMwb,QAAO,CAACC,EAAUC,KAC1DD,EAAIC,EAAI1V,IAAM,OAAH,wBAAO0V,GAAG,CAAE7Z,QAAS6Z,EAAIrQ,WAAa,EAAGrI,IAAK0Y,EAAI1V,GAAIuH,WAAYmO,EAAI3V,mBAC1E0V,IACN,CAAC,IAGCpX,CACT,EAKA,4BAAiCrE,GAa/B,MAZe,KACVA,aAAK,EAALA,EAAOsE,KAAIuE,IAAQ,CACpB5C,KAAM,OAAF,wBACC4C,GAAI,CACPhH,QAAQgH,EAAKwC,UACbrI,IAAK6F,EAAK7C,GACVuH,WAAY1E,EAAK9C,mBAEnBrB,KAAM,UAAUN,YACX,GAIX,C,gHCnDa,EAAA+W,gBAAkB,eAElB,EAAAT,sBAAwB,S,+ECSrC,iBAA+CiB,GAC7C,OAAO,cAAyBA,EAC9B,EAAAC,CAAG9W,EAA4B+W,EAAoCvc,GAEjE,OADAhF,KAAK6e,QAAQyC,GAAG9W,EAAW+W,EAAUvc,GAC9BhF,IACT,CAEA,WAAAuR,CAAY/G,EAA4B+W,EAAoCvc,GAE1E,OADAhF,KAAK6e,QAAQtN,YAAY/G,EAAW+W,EAAUvc,GACvChF,IACT,CAEA,IAAAwhB,CAAKhX,EAA4B+W,EAAoCvc,GAEnE,OADAhF,KAAK6e,QAAQ2C,KAAKhX,EAAW+W,EAAUvc,GAChChF,IACT,CAEA,cAAAyhB,CAAejX,EAA4B+W,EAAoCvc,GAE7E,OADAhF,KAAK6e,QAAQ4C,eAAejX,EAAW+W,EAAUvc,GAC1ChF,IACT,CAEA,GAAA0hB,CAAIlX,EAA4B+W,EAAkCvc,GAEhE,OADAhF,KAAK6e,QAAQ6C,IAAIlX,EAAW+W,EAAUvc,GAC/BhF,IACT,CAEA,kBAAA2hB,CAAmBnQ,GAEjB,OADAxR,KAAK6e,QAAQ8C,mBAAmBnQ,GACzBxR,IACT,CAEA,SAAAkH,CAAUsD,GACR,OAAOxK,KAAK6e,QAAQ3X,UAAUsD,EAChC,CAEA,IAAA+U,CAAK/U,KAA+B4P,GAElC,OADApa,KAAK6e,QAAQU,KAAK/U,EAAW4P,GACtBpa,IACT,CAEA,aAAA8f,CAActV,GACZ,OAAOxK,KAAK6e,QAAQiB,cAActV,EACpC,CAEA,eAAAoX,CAAgBpX,EAA4B+W,EAAoCvc,GAE9E,OADAhF,KAAK6e,QAAQ+C,gBAAgBpX,EAAW+W,EAAUvc,GAC3ChF,IACT,CAEA,mBAAA6hB,CAAoBrX,EAA4B+W,EAAoCvc,GAElF,OADAhF,KAAK6e,QAAQgD,oBAAoBrX,EAAW+W,EAAUvc,GAC/ChF,IACT,CAEA,UAAA+f,GACE,OAAO/f,KAAK6e,QAAQkB,YACtB,CAEA,gBAAA+B,CAAkBve,GAEhB,OADAvD,KAAK6e,QAAQiD,iBAAiBve,GACvBvD,IACT,EAEJ,C,sFCjEA,qBAGE,WAAAgC,CAAoBrB,GAAA,KAAAA,OAAAA,EAFZ,KAAAqW,OAAiB,CAAC,CAEa,CAE/B,WAAA+K,CAAavQ,GACnB,QAASxR,KAAKgX,OAAOxF,EACvB,CAEA,EAAA8P,CAAI9P,EAAwBwQ,EAAmChd,GAO7D,OANAhF,KAAKgX,OAAOxF,GAASxR,KAAKgX,OAAOxF,IAAU,GAC3CxR,KAAKgX,OAAOxF,GAASxR,KAAKgX,OAAOxF,GAAOyQ,OAAO,CAC7CD,QAASA,EACThd,QAASA,IAGJhF,IACT,CAEA,WAAAuR,CAAaC,EAAwBwQ,EAAmChd,GACtE,OAAOhF,KAAKshB,GAAG9P,EAAOwQ,EAAShd,EACjC,CAEA,IAAAwc,CAAMhQ,EAAwBwQ,EAAmChd,GAC/D,MAAMkd,EAAc,IAAI9H,KACtBpa,KAAK0hB,IAAIlQ,EAAO0Q,EAAald,GAC7Bgd,EAAQG,MAAMnd,EAASoV,EAAK,EAE9B,OAAOpa,KAAKshB,GAAG9P,EAAO0Q,EAAald,EACrC,CAEA,GAAA0c,CAAKlQ,EAAwBwQ,EAAmChd,GAC9D,IAAKhF,KAAKgX,OAAOxF,GACf,OAAOxR,KAET,IAAK,IAAID,EAAI,EAAGA,EAAIC,KAAKgX,OAAOxF,GAAOvN,OAAQlE,IACzCC,KAAKgX,OAAOxF,GAAOzR,GAAGiiB,UAAYA,GAAWhiB,KAAKgX,OAAOxF,GAAOzR,GAAGiF,UAAYA,IACjFhF,KAAKgX,OAAOxF,GAASxR,KAAKgX,OAAOxF,GAAOQ,MAAM,EAAGjS,GAAGkiB,OAAOjiB,KAAKgX,OAAOxF,GAAOQ,MAAMjS,EAAI,KAI5F,OAAOC,IACT,CAEA,cAAAyhB,CAAgBjQ,EAAwBwQ,EAAmChd,GACzE,OAAOhF,KAAK0hB,IAAIlQ,EAAOwQ,EAAShd,EAClC,CAEA,kBAAA2c,CAAoBnQ,GAOlB,OANIA,SACKxR,KAAKgX,OAAOxF,GAEnBxR,KAAKgX,OAAS,CAAC,EAGVhX,IACT,CAEA,SAAAkH,CAAWsK,GACT,OAAOxR,KAAKgX,OAAOxF,GAASxR,KAAKgX,OAAOxF,GAAOxH,KAAKwH,GAAUA,EAAMwQ,UAAW,EACjF,CAEA,IAAAzC,CAAM/N,KAA2B4I,GAC/B,IAAKpa,KAAKgX,OAAOxF,GACf,OAAOxR,KAKT,MAAMoiB,EAAiB,IAAIpiB,KAAKgX,OAAOxF,IACvC,IAAK,IAAIzR,EAAI,EAAGA,EAAIqiB,EAAene,OAAQlE,IACzCqiB,EAAeriB,GAAGiiB,QAAQG,MAAMC,EAAeriB,GAAGiF,QAAS6X,MAAMjC,UAAU5I,MAAM8I,KAAKuH,UAAW,IAGnG,OAAOriB,IACT,CAEA,aAAA8f,CAAetO,GACb,OAAOxR,KAAKgX,OAAOxF,GAASxR,KAAKgX,OAAOxF,GAAOvN,OAAS,CAC1D,CAEA,eAAA2d,CAAiBpQ,EAAwBwQ,EAAmChd,GAU1E,OATAhF,KAAKgX,OAAOxF,GAASxR,KAAKgX,OAAOxF,IAAU,GAC3CxR,KAAKgX,OAAOxF,GAAS,CACnB,CACEwQ,QAASA,EACThd,QAASA,MAERhF,KAAKgX,OAAOxF,IAGVxR,IACT,CAEA,mBAAA6hB,CAAqBrQ,EAAwBwQ,EAAmChd,GAC9E,MAAMkd,EAAc,IAAI9H,KACtBpa,KAAK0hB,IAAIlQ,EAAO0Q,EAAald,GAC7Bgd,EAAQG,MAAMnd,EAASoV,EAAK,EAE9B,OAAOpa,KAAK4hB,gBAAgBpQ,EAAO0Q,EAAald,EAClD,CAEA,UAAA+a,GACE,OAAOnf,OAAOyB,KAAKrC,KAAKgX,OAC1B,CAEA,gBAAA8K,CAAkBve,G,MAChB,OAAKA,GAGDvD,KAAK+hB,YAAY,SACnB/hB,KAAKuf,KAAK,QAAShc,GAER,QAAX,EAAAvD,KAAKW,cAAM,SAAE4C,MAAMA,GAGdvD,MAREA,IASX,E,iFC/HF,gBAEA,MAAayV,EAIX,iBAAOC,CAAW4M,GAChB,IAAI5c,EAAQ,GACZ,MAAM+X,EAAQ6E,EAAc7E,MAAMhI,EAAM8M,kBAOxC,OALI9E,IACF6E,EAAgB7E,EAAM,GACtB/X,EAAQ+X,EAAM,IAGT,IAAI+E,OAAOF,EAAe5c,EACnC,CAEA,yBAAO+c,CAAmBC,GACxB,OAAO,IAAAjf,mBAAkBif,KAASA,EAAItQ,QAAQqD,EAAMkN,gBAAiB,IAAI1e,MAC3E,EAlBF,UACiB,EAAAse,iBAAmB,oBACnB,EAAAI,gBAAkB,K,yFCGnC,MAAa9Z,EACX,WAAOC,CAAK5D,GACV,MAA6B,UAAzBA,aAAK,EAALA,EAAO8Q,eACFnN,EAAgB+Z,SAAiB,GAGb,WAAzB1d,aAAK,EAALA,EAAO8Q,eACFnN,EAAgB+Z,SAAiB,GAGnC/Z,EAAgBtF,OACzB,CAEA,aAAO6F,CAAOlE,GACZ,MAAM2d,EAAMziB,OAAO8E,GAEnB,OAAI9E,OAAOgU,MAAMyO,GACRha,EAAgBtF,QAGlBsF,EAAgB+Z,QAAgBC,EACzC,CAEA,aAAOtZ,CAAOrE,GACZ,OAAO2D,EAAgB+Z,QAAgB1d,EACzC,CAEA,WAAO+D,CAAK/D,GACV,IACE,MAAM4N,EAAM/C,KAAKC,MAAM9K,GACvB,OAAO2D,EAAgB+Z,QAAiB9P,E,CACxC,MAAO9H,GACP,OAAOnC,EAAgBtF,O,CAE3B,CAEQ,cAAOqf,CAAgB1d,GAC7B,MAAO,CACLmG,aAAa,EACbnG,MAAOA,EAEX,CAEQ,YAAO3B,GACb,MAAO,CACL8H,aAAa,EAEjB,EA/CF,mB,wJCNA,2BAAgCoF,GAC9B,OAAOA,EAAI2B,QAAQ,OAAQ,GAC7B,C,2GCKA,0BACE/R,EACA+D,GAEA,MAAM,cAACma,EAAa,QAAEhX,GAAWnD,EAAKka,UAQtC,MANyB,CACvB,eAAgB,mBAChB,aAAc,GAAIC,QAAAA,EAAiBna,EAAKwG,WAAarD,IACrD,cAAiBlH,EAIrB,EAEA,4BACE2K,EAIAhG,EACA8d,GAEA,IAAIC,EAOJ,OALEA,EADE/X,EAAIyE,OACC,SAAUzE,EAAIyE,SAA0B,MAAfzE,EAAIyE,OAAiB,qBAAuB,KAErE,cAAezE,EAAItG,SAAWsG,KAGhC,YAAa+X,SAAc/d,OADnB8d,QAAAA,EAAgB,yBAEjC,C,4fCvCA,aACA,aACA,aACA,Y,2FCHA,6BAAkChQ,GAChC,OAAOA,OACT,C,uFCAA,yBAA8BtR,G,MAC5B,OAAKA,EAuBE,GAnBsBA,EAAKqD,SAASrD,EAAKsD,QAEM,QAAzB,EAAAtD,EAAK4D,4BAAoB,eAClD4d,MAAK,CAACljB,EAAGmjB,KACT,MAAMC,EAAQpjB,EAAEgF,KAAKqe,cACfC,EAAQH,EAAEne,KAAKqe,cACrB,OAAID,EAAQE,GACF,EAGNF,EAAQE,EACH,EAGF,CAAC,IAETpZ,KAAIqZ,GAAK,GAAGA,EAAEve,QAAQue,EAAEne,UACxBiN,KAAK,OApBC,EAuBX,C,sYCtBA,UALc,CAAOmR,EAAsB,MAAQ,oCACjD,WAAIjb,SAASC,IACXV,WAAWU,EAASgb,EAAY,G,2FCFvB,EAAA/b,QAAU,QAAsB,EAAAzC,KAAO,wB,GCChDye,EAA2B,CAAC,E,OAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqB1hB,IAAjB2hB,EACH,OAAOA,EAAahkB,QAGrB,IAAIC,EAAS4jB,EAAyBE,GAAY,CAGjD/jB,QAAS,CAAC,GAOX,OAHAikB,EAAoBF,GAAU3I,KAAKnb,EAAOD,QAASC,EAAQA,EAAOD,QAAS8jB,GAGpE7jB,EAAOD,OACf,CCnB0B8jB,CAAoB,K","sources":["webpack://@featbit/js-client-sdk/webpack/universalModuleDefinition","webpack://@featbit/js-client-sdk/./src/Configuration.ts","webpack://@featbit/js-client-sdk/./src/Context.ts","webpack://@featbit/js-client-sdk/./src/FbClientBuilder.ts","webpack://@featbit/js-client-sdk/./src/FbClientCore.ts","webpack://@featbit/js-client-sdk/./src/bootstrap/JsonBootstrapProvider.ts","webpack://@featbit/js-client-sdk/./src/bootstrap/NullBootstrapProvider.ts","webpack://@featbit/js-client-sdk/./src/bootstrap/index.ts","webpack://@featbit/js-client-sdk/./src/constants.ts","webpack://@featbit/js-client-sdk/./src/data-sources/DataSourceUpdates.ts","webpack://@featbit/js-client-sdk/./src/data-sources/NamespacedDataSet.ts","webpack://@featbit/js-client-sdk/./src/data-sources/createStreamListeners.ts","webpack://@featbit/js-client-sdk/./src/data-sources/index.ts","webpack://@featbit/js-client-sdk/./src/data-sync/DataSyncMode.ts","webpack://@featbit/js-client-sdk/./src/data-sync/NullDataSynchronizer.ts","webpack://@featbit/js-client-sdk/./src/data-sync/PollingDataSynchronizer.ts","webpack://@featbit/js-client-sdk/./src/data-sync/Requestor.ts","webpack://@featbit/js-client-sdk/./src/data-sync/WebSocketDataSynchronizer.ts","webpack://@featbit/js-client-sdk/./src/data-sync/index.ts","webpack://@featbit/js-client-sdk/./src/data-sync/types.ts","webpack://@featbit/js-client-sdk/./src/data-sync/utils.ts","webpack://@featbit/js-client-sdk/./src/errors.ts","webpack://@featbit/js-client-sdk/./src/evaluation/EvalResult.ts","webpack://@featbit/js-client-sdk/./src/evaluation/Evaluator.ts","webpack://@featbit/js-client-sdk/./src/evaluation/ReasonKinds.ts","webpack://@featbit/js-client-sdk/./src/evaluation/data/IFlag.ts","webpack://@featbit/js-client-sdk/./src/evaluation/data/index.ts","webpack://@featbit/js-client-sdk/./src/evaluation/index.ts","webpack://@featbit/js-client-sdk/./src/evaluation/operator.ts","webpack://@featbit/js-client-sdk/./src/events/DefaultEventProcessor.ts","webpack://@featbit/js-client-sdk/./src/events/DefaultEventQueue.ts","webpack://@featbit/js-client-sdk/./src/events/DefaultEventSender.ts","webpack://@featbit/js-client-sdk/./src/events/DefaultEventSerializer.ts","webpack://@featbit/js-client-sdk/./src/events/EventDispatcher.ts","webpack://@featbit/js-client-sdk/./src/events/IEventSender.ts","webpack://@featbit/js-client-sdk/./src/events/NullEventProcessor.ts","webpack://@featbit/js-client-sdk/./src/events/event.ts","webpack://@featbit/js-client-sdk/./src/events/index.ts","webpack://@featbit/js-client-sdk/./src/index.ts","webpack://@featbit/js-client-sdk/./src/logging/BasicLogger.ts","webpack://@featbit/js-client-sdk/./src/logging/SafeLogger.ts","webpack://@featbit/js-client-sdk/./src/logging/format.ts","webpack://@featbit/js-client-sdk/./src/logging/index.ts","webpack://@featbit/js-client-sdk/./src/options/ClientContext.ts","webpack://@featbit/js-client-sdk/./src/options/OptionMessages.ts","webpack://@featbit/js-client-sdk/./src/options/UserBuilder.ts","webpack://@featbit/js-client-sdk/./src/options/Validators.ts","webpack://@featbit/js-client-sdk/./src/options/index.ts","webpack://@featbit/js-client-sdk/./src/platform/browser/BrowserInfo.ts","webpack://@featbit/js-client-sdk/./src/platform/browser/BrowserPlatform.ts","webpack://@featbit/js-client-sdk/./src/platform/browser/BrowserRequests.ts","webpack://@featbit/js-client-sdk/./src/platform/browser/BrowserWebSocket.ts","webpack://@featbit/js-client-sdk/./src/platform/browser/FbClient.ts","webpack://@featbit/js-client-sdk/./src/platform/browser/LocalStorageStore.ts","webpack://@featbit/js-client-sdk/./src/platform/index.ts","webpack://@featbit/js-client-sdk/./src/store/DataKinds.ts","webpack://@featbit/js-client-sdk/./src/store/InMemoryStore.ts","webpack://@featbit/js-client-sdk/./src/store/index.ts","webpack://@featbit/js-client-sdk/./src/store/serialization.ts","webpack://@featbit/js-client-sdk/./src/store/store.ts","webpack://@featbit/js-client-sdk/./src/utils/Emits.ts","webpack://@featbit/js-client-sdk/./src/utils/EventEmitter.ts","webpack://@featbit/js-client-sdk/./src/utils/Regex.ts","webpack://@featbit/js-client-sdk/./src/utils/ValueConverters.ts","webpack://@featbit/js-client-sdk/./src/utils/canonicalizeUri.ts","webpack://@featbit/js-client-sdk/./src/utils/http.ts","webpack://@featbit/js-client-sdk/./src/utils/index.ts","webpack://@featbit/js-client-sdk/./src/utils/isNullOrUndefined.ts","webpack://@featbit/js-client-sdk/./src/utils/serializeUser.ts","webpack://@featbit/js-client-sdk/./src/utils/sleep.ts","webpack://@featbit/js-client-sdk/./src/version.ts","webpack://@featbit/js-client-sdk/webpack/bootstrap","webpack://@featbit/js-client-sdk/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, () => {\nreturn ","import { IOptions } from \"./options/IOptions\";\r\nimport { ILogger } from \"./logging/ILogger\";\r\nimport { IValidatedOptions } from \"./options/IValidatedOptions\";\r\nimport { NumberWithMinimum, TypeValidator, TypeValidators, UserValidator } from \"./options/Validators\";\r\nimport OptionMessages from \"./options/OptionMessages\";\r\nimport { IStore } from \"./platform/IStore\";\r\nimport { IClientContext } from \"./options/IClientContext\";\r\nimport { IDataSynchronizer } from \"./data-sync/IDataSynchronizer\";\r\nimport { IDataSourceUpdates } from \"./store/IDataSourceUpdates\";\r\nimport InMemoryStore from \"./store/InMemoryStore\";\r\nimport { VoidFunction } from \"./utils/VoidFunction\";\r\nimport { isNullOrUndefined } from \"./utils/isNullOrUndefined\";\r\nimport { canonicalizeUri } from \"./utils/canonicalizeUri\";\r\nimport { IBootstrapProvider } from \"./bootstrap/IBootstrapProvider\";\r\nimport { NullBootstrapProvider } from \"./bootstrap/NullBootstrapProvider\";\r\nimport { EmptyString } from \"./constants\";\r\nimport { DataSyncModeEnum } from \"./data-sync/DataSyncMode\";\r\nimport { IUser } from \"./options/IUser\";\r\nimport LocalStorageStore from \"./platform/browser/LocalStorageStore\";\r\nimport { JsonBootstrapProvider } from \"./bootstrap\";\r\n\r\n// Once things are internal to the implementation of the SDK we can depend on\r\n// types. Calls to the SDK could contain anything without any regard to typing.\r\n// So, data we take from external sources must be normalized into something\r\n// that can be trusted.\r\n\r\n/**\r\n * These perform cursory validations. Complex objects are implemented with classes\r\n * and these should allow for conditional construction.\r\n */\r\nconst validations: Record<string, TypeValidator> = {\r\n  startWaitTime: TypeValidators.Number,\r\n  sdkKey: TypeValidators.String,\r\n  pollingUri: TypeValidators.String,\r\n  streamingUri: TypeValidators.String,\r\n  eventsUri: TypeValidators.String,\r\n  webSocketPingInterval: TypeValidators.Number,\r\n  logger: TypeValidators.Object,\r\n  store: TypeValidators.ObjectOrFactory,\r\n  dataSynchronizer: TypeValidators.ObjectOrFactory,\r\n  flushInterval: TypeValidators.Number,\r\n  maxEventsInQueue: TypeValidators.Number,\r\n  pollingInterval: TypeValidators.Number,\r\n  offline: TypeValidators.Boolean,\r\n  dataSyncMode: TypeValidators.String,\r\n  bootstrap: TypeValidators.Bootstrap,\r\n  user: TypeValidators.User\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const defaultValues: IValidatedOptions = {\r\n  startWaitTime: 5000,\r\n  sdkKey: '',\r\n  pollingUri: '',\r\n  streamingUri: '',\r\n  eventsUri: '',\r\n  dataSyncMode: DataSyncModeEnum.STREAMING,\r\n  sendEvents: true,\r\n  webSocketPingInterval: 18 * 1000,\r\n  flushInterval: 2000,\r\n  maxEventsInQueue: 10000,\r\n  pollingInterval: 30000,\r\n  offline: false,\r\n  store: (options: IOptions) => new LocalStorageStore(options),\r\n  bootstrap: undefined,\r\n  user: undefined,\r\n};\r\n\r\nfunction validateTypesAndNames(options: IOptions): {\r\n  errors: string[];\r\n  validatedOptions: IValidatedOptions;\r\n} {\r\n  let errors: string[] = [];\r\n  const validatedOptions: IValidatedOptions = {...defaultValues};\r\n  Object.keys(options).forEach((optionName) => {\r\n    // We need to tell typescript it doesn't actually know what options are.\r\n    // If we don't then it complains we are doing crazy things with it.\r\n    const optionValue = (options as unknown as any)[optionName];\r\n    const validator = validations[optionName];\r\n    if (validator) {\r\n      if (!validator.is(optionValue)) {\r\n        if (validator.getType() === 'boolean') {\r\n          errors.push(OptionMessages.wrongOptionTypeBoolean(optionName, typeof optionValue));\r\n          validatedOptions[optionName] = !!optionValue;\r\n        } else if (\r\n          validator instanceof NumberWithMinimum &&\r\n          TypeValidators.Number.is(optionValue)\r\n        ) {\r\n          const {min} = validator as NumberWithMinimum;\r\n          errors.push(OptionMessages.optionBelowMinimum(optionName, optionValue, min));\r\n          validatedOptions[optionName] = min;\r\n        } else if (validator instanceof UserValidator) {\r\n          errors = [...errors, ...validator.messages];\r\n          validatedOptions[optionName] = defaultValues[optionName];\r\n        } else {\r\n          errors.push(\r\n            OptionMessages.wrongOptionType(optionName, validator.getType(), typeof optionValue),\r\n          );\r\n          validatedOptions[optionName] = defaultValues[optionName];\r\n        }\r\n      } else {\r\n        validatedOptions[optionName] = optionValue;\r\n      }\r\n    } else {\r\n      options.logger?.warn(OptionMessages.unknownOption(optionName));\r\n    }\r\n  });\r\n  return {errors, validatedOptions};\r\n}\r\n\r\nfunction validateEndpoints(options: IOptions, validatedOptions: IValidatedOptions) {\r\n  const {streamingUri, pollingUri, eventsUri} = options;\r\n  const streamingUriMissing = isNullOrUndefined(streamingUri) || streamingUri === EmptyString;\r\n  const pollingUriMissing = isNullOrUndefined(pollingUri) || pollingUri === EmptyString;\r\n  const eventsUriMissing = isNullOrUndefined(eventsUri) || eventsUri === EmptyString;\r\n\r\n  if (!validatedOptions.offline && (eventsUriMissing || (streamingUriMissing && pollingUriMissing))) {\r\n    if (eventsUriMissing) {\r\n      validatedOptions.logger?.error(OptionMessages.partialEndpoint('eventsUri'));\r\n    }\r\n\r\n    if (validatedOptions.dataSyncMode === DataSyncModeEnum.STREAMING && streamingUriMissing) {\r\n      validatedOptions.logger?.error(OptionMessages.partialEndpoint('streamingUri'));\r\n    }\r\n\r\n    if (validatedOptions.dataSyncMode === DataSyncModeEnum.POLLING && pollingUriMissing) {\r\n      validatedOptions.logger?.error(OptionMessages.partialEndpoint('pollingUri'));\r\n    }\r\n  }\r\n}\r\n\r\nexport default class Configuration {\r\n  public readonly startWaitTime: number;\r\n\r\n  public readonly sdkKey: string;\r\n\r\n  public readonly streamingUri: string;\r\n\r\n  public readonly pollingUri: string;\r\n\r\n  public readonly eventsUri: string;\r\n\r\n  public readonly webSocketPingInterval: number;\r\n\r\n  public readonly logger?: ILogger;\r\n\r\n  public readonly flushInterval: number;\r\n\r\n  public readonly maxEventsInQueue: number;\r\n\r\n  public readonly pollingInterval: number;\r\n\r\n  public readonly offline: boolean;\r\n\r\n  public readonly dataSyncMode: DataSyncModeEnum;\r\n\r\n  public readonly bootstrapProvider: IBootstrapProvider = new NullBootstrapProvider();\r\n\r\n  public readonly user: IUser;\r\n\r\n  public readonly storeFactory: (clientContext: IClientContext) => IStore;\r\n\r\n  public readonly dataSynchronizerFactory?: (\r\n    clientContext: IClientContext,\r\n    store: IStore,\r\n    dataSourceUpdates: IDataSourceUpdates,\r\n    initSuccessHandler: VoidFunction,\r\n    errorHandler?: (e: Error) => void,\r\n  ) => IDataSynchronizer;\r\n\r\n  constructor(options: IOptions = {}) {\r\n    // The default will handle undefined, but not null.\r\n    // Because we can be called from JS we need to be extra defensive.\r\n    options = options || {};\r\n    // If there isn't a valid logger from the platform, then logs would go nowhere.\r\n    this.logger = options.logger;\r\n\r\n    const {errors, validatedOptions} = validateTypesAndNames(options);\r\n    errors.forEach((error) => {\r\n      this.logger?.warn(error);\r\n    });\r\n\r\n    this.user = options.user!;\r\n\r\n    validateEndpoints(options, validatedOptions);\r\n    this.streamingUri = `${ canonicalizeUri(validatedOptions.streamingUri) }/streaming`;\r\n    this.pollingUri = `${ canonicalizeUri(validatedOptions.pollingUri) }/api/public/sdk/client/latest-all`;\r\n    this.eventsUri = `${ canonicalizeUri(validatedOptions.eventsUri) }/api/public/insight/track`;\r\n\r\n    this.startWaitTime = validatedOptions.startWaitTime;\r\n\r\n    this.sdkKey = validatedOptions.sdkKey;\r\n    this.webSocketPingInterval = validatedOptions.webSocketPingInterval!;\r\n\r\n    this.flushInterval = validatedOptions.flushInterval;\r\n    this.maxEventsInQueue = validatedOptions.maxEventsInQueue;\r\n    this.pollingInterval = validatedOptions.pollingInterval;\r\n\r\n    this.offline = validatedOptions.offline;\r\n    if (validatedOptions.bootstrap && validatedOptions.bootstrap.length > 0) {\r\n      try {\r\n        this.bootstrapProvider = new JsonBootstrapProvider(validatedOptions.bootstrap);\r\n      } catch (_) {\r\n        this.logger?.error('Failed to parse bootstrap JSON, use NullBootstrapProvider.');\r\n      }\r\n    }\r\n\r\n    if (this.offline) {\r\n      this.logger?.info('Offline mode enabled. No data synchronization with the FeatBit server will occur.');\r\n    }\r\n\r\n    this.dataSyncMode = validatedOptions.dataSyncMode;\r\n\r\n    if (TypeValidators.Function.is(validatedOptions.dataSynchronizer)) {\r\n      // @ts-ignore\r\n      this.dataSynchronizerFactory = validatedOptions.dataSynchronizer;\r\n    } else {\r\n      // The processor is already created, just have the method return it.\r\n      // @ts-ignore\r\n      this.dataSynchronizerFactory = () => validatedOptions.dataSynchronizer;\r\n    }\r\n\r\n    if (TypeValidators.Function.is(validatedOptions.store)) {\r\n      // @ts-ignore\r\n      this.storeFactory = validatedOptions.store;\r\n    } else {\r\n      // The store is already created, just have the method return it.\r\n      // @ts-ignore\r\n      this.storeFactory = () => validatedOptions.store;\r\n    }\r\n  }\r\n}","import { IUser } from \"./options/IUser\";\r\n\r\nexport default class Context {\r\n  private _user?: IUser;\r\n  /**\r\n   * Is this a valid context. If a valid context cannot be created, then this flag will be true.\r\n   * The validity of a context should be tested before it is used.\r\n   */\r\n  public readonly valid: boolean;\r\n\r\n  public readonly message?: string;\r\n\r\n  /**\r\n   * Contexts should be created using the static factory method {@link Context.fromUser}.\r\n   *\r\n   * The factory methods are static functions within the class because they access private\r\n   * implementation details, so they cannot be free functions.\r\n   */\r\n  private constructor(valid: boolean, message?: string) {\r\n    this.valid = valid;\r\n    this.message = message;\r\n  }\r\n\r\n  public static fromUser(user: IUser): Context {\r\n    if (!user) {\r\n      return Context.contextForError('No user specified');\r\n    }\r\n\r\n    const {keyId, name} = user;\r\n\r\n    if (keyId === undefined || keyId === null || keyId.trim() === '') {\r\n      return Context.contextForError('key is mandatory');\r\n    }\r\n\r\n    const context = new Context(true);\r\n    context._user = user;\r\n\r\n    return context;\r\n  }\r\n\r\n  get user(): IUser {\r\n    return this._user!;\r\n  }\r\n\r\n  get keyId(): string {\r\n    return this._user!.keyId;\r\n  }\r\n\r\n  value(property: string): any {\r\n    if (property === 'keyId') {\r\n      return this._user?.keyId;\r\n    } else if (property === 'name') {\r\n      return this._user?.name;\r\n    } else {\r\n      return this._user?.customizedProperties?.find(x => x.name === property)?.value;\r\n    }\r\n  }\r\n\r\n  private static contextForError(message: string) {\r\n    return new Context(false, message);\r\n  }\r\n}","import { IFbClient } from \"./IFbClient\";\r\nimport { IOptions } from \"./options/IOptions\";\r\nimport FbClient from \"./platform/browser/FbClient\";\r\nimport { IDataSynchronizer } from \"./data-sync/IDataSynchronizer\";\r\nimport { IClientContext } from \"./options/IClientContext\";\r\nimport { IDataSourceUpdates } from \"./store/IDataSourceUpdates\";\r\nimport { VoidFunction } from \"./utils/VoidFunction\";\r\nimport { ILogger } from \"./logging/ILogger\";\r\nimport { DataSyncModeEnum } from \"./data-sync/DataSyncMode\";\r\nimport { IUser } from \"./options/IUser\";\r\nimport { IFlagBase } from \"./evaluation\";\r\n\r\n/**\r\n * Creates an instance of the FeatBit client.\r\n *\r\n * Applications should instantiate a single instance for the lifetime of the application.\r\n * The client will begin attempting to connect to FeatBit as soon as it is created. To\r\n * determine when it is ready to use, call {@link IFbClient.waitForInitialization}, or register an\r\n * event listener for the `\"ready\"` event using {@link IFbClient.on}.\r\n *\r\n * **Important:** Do **not** try to instantiate `FbClient` with its constructor\r\n * (`new FbClientNode()`); the SDK does not currently support\r\n * this.\r\n *\r\n * @return\r\n *   The new {@link IFbClient} instance.\r\n */\r\nexport class FbClientBuilder {\r\n  private _options: IOptions;\r\n\r\n  constructor(options?: IOptions) {\r\n    this._options = options ?? {};\r\n  }\r\n\r\n  /**\r\n   * Creates a new instance of the FeatBit client.\r\n   */\r\n  build(): IFbClient {\r\n    return new FbClient(this._options);\r\n  }\r\n\r\n  /**\r\n   * Refer to {@link IOptions.startWaitTime}.\r\n   */\r\n  startWaitTime(startWaitTime: number): FbClientBuilder {\r\n    this._options.startWaitTime = startWaitTime;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Refer to {@link IOptions.sdkKey}.\r\n   */\r\n  sdkKey(sdkKey: string): FbClientBuilder {\r\n    this._options.sdkKey = sdkKey;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Refer to {@link IOptions.user}.\r\n   */\r\n  user(user: IUser): FbClientBuilder {\r\n    this._options.user = user;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Refer to {@link IOptions.streamingUri}.\r\n   */\r\n  streamingUri(streamingUri: string): FbClientBuilder {\r\n    this._options.streamingUri = streamingUri;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Refer to {@link IOptions.pollingUri}.\r\n   */\r\n  pollingUri(pollingUri: string): FbClientBuilder {\r\n    this._options.pollingUri = pollingUri;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Refer to {@link IOptions.eventsUri}.\r\n   */\r\n  eventsUri(eventsUri: string): FbClientBuilder {\r\n    this._options.eventsUri = eventsUri;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Refer to {@link IOptions.dataSyncMode}.\r\n   */\r\n  dataSyncMode(mode: DataSyncModeEnum): FbClientBuilder {\r\n    this._options.dataSyncMode = mode;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Refer to {@link IOptions.pollingInterval}.\r\n   */\r\n  pollingInterval(pollingInterval: number): FbClientBuilder {\r\n    this._options.pollingInterval = pollingInterval;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Refer to {@link IOptions.flushInterval}.\r\n   */\r\n  flushInterval(flushInterval: number): FbClientBuilder {\r\n    this._options.flushInterval = flushInterval;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Refer to {@link IOptions.maxEventsInQueue}.\r\n   */\r\n  maxEventsInQueue(maxEventsInQueue: number): FbClientBuilder {\r\n    this._options.maxEventsInQueue = maxEventsInQueue;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Refer to {@link IOptions.logger}.\r\n   */\r\n  logger(logger: ILogger): FbClientBuilder {\r\n    this._options.logger = logger;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Refer to {@link IOptions.offline}.\r\n   */\r\n  offline(offline: boolean): FbClientBuilder {\r\n    this._options.offline = offline;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Use the JsonBootstrapProvider.\r\n   */\r\n  bootstrap(flags: IFlagBase[]): FbClientBuilder {\r\n    this._options.bootstrap = flags;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Refer to {@link IOptions.dataSynchronizer}.\r\n   */\r\n  dataSynchronizer(\r\n    dataSynchronizer: IDataSynchronizer |\r\n    ((\r\n      clientContext: IClientContext,\r\n      dataSourceUpdates: IDataSourceUpdates,\r\n      initSuccessHandler: VoidFunction,\r\n      errorHandler?: (e: Error) => void,\r\n    ) => IDataSynchronizer)\r\n  ): FbClientBuilder {\r\n    this._options.dataSynchronizer = dataSynchronizer;\r\n    return this;\r\n  }\r\n}","import { IFbClientCore } from \"./IFbClientCore\";\r\nimport { IPlatform } from \"./platform/IPlatform\";\r\nimport Configuration from \"./Configuration\";\r\nimport { ILogger } from \"./logging/ILogger\";\r\nimport ClientContext from \"./options/ClientContext\";\r\nimport DataSourceUpdates from \"./data-sources/DataSourceUpdates\";\r\nimport { createStreamListeners } from \"./data-sources/createStreamListeners\";\r\nimport { IEvalDetail } from \"./evaluation/IEvalDetail\";\r\nimport WebSocketDataSynchronizer from \"./data-sync/WebSocketDataSynchronizer\";\r\nimport PollingDataSynchronizer from \"./data-sync/PollingDataSynchronizer\";\r\nimport Requestor from \"./data-sync/Requestor\";\r\nimport { IDataSynchronizer } from \"./data-sync/IDataSynchronizer\";\r\nimport DataKinds from \"./store/DataKinds\";\r\nimport Evaluator from \"./evaluation/Evaluator\";\r\nimport { ReasonKinds } from \"./evaluation/ReasonKinds\";\r\nimport { ClientError } from \"./errors\";\r\nimport Context from \"./Context\";\r\nimport { IConvertResult, ValueConverters } from \"./utils/ValueConverters\";\r\nimport { NullDataSynchronizer } from \"./data-sync/NullDataSynchronizer\";\r\nimport { IEventProcessor } from \"./events/IEventProcessor\";\r\nimport { NullEventProcessor } from \"./events/NullEventProcessor\";\r\nimport { DefaultEventProcessor } from \"./events/DefaultEventProcessor\";\r\nimport { IStore } from \"./platform/IStore\";\r\nimport { IOptions } from \"./options/IOptions\";\r\nimport { MetricEvent } from \"./events/event\";\r\nimport { DataSyncModeEnum } from \"./data-sync/DataSyncMode\";\r\nimport { IUser } from \"./options/IUser\";\r\nimport { UserValidator } from \"./options/Validators\";\r\n\r\nenum ClientState {\r\n  Initializing,\r\n  Initialized,\r\n  Failed,\r\n}\r\n\r\nexport interface IClientCallbacks {\r\n  onError: (err: Error) => void;\r\n  onFailed: (err: Error) => void;\r\n  onReady: () => void;\r\n  // Called whenever flags change, if there are listeners.\r\n  onUpdate: (keys: string[]) => void;\r\n  // Method to check if event listeners have been registered.\r\n  // If none are registered, then onUpdate will never be called.\r\n  hasEventListeners: () => boolean;\r\n}\r\n\r\nexport class FbClientCore implements IFbClientCore {\r\n  private state: ClientState = ClientState.Initializing;\r\n\r\n  private store?: IStore;\r\n\r\n  private dataSynchronizer?: IDataSynchronizer;\r\n\r\n  private eventProcessor?: IEventProcessor;\r\n\r\n  private evaluator?: Evaluator;\r\n\r\n  private initResolve?: (value: IFbClientCore | PromiseLike<IFbClientCore>) => void;\r\n\r\n  private initReject?: (err: Error) => void;\r\n\r\n  private rejectionReason: Error | undefined;\r\n\r\n  private initializedPromise?: Promise<IFbClientCore>;\r\n\r\n  private logger?: ILogger;\r\n\r\n  private config: Configuration;\r\n\r\n  private onError: (err: Error) => void;\r\n\r\n  private onFailed: (err: Error) => void;\r\n\r\n  private onReady: () => void;\r\n\r\n  constructor(\r\n    private options: IOptions,\r\n    private platform: IPlatform,\r\n    callbacks: IClientCallbacks\r\n  ) {\r\n    this.onError = callbacks.onError;\r\n    this.onFailed = callbacks.onFailed;\r\n    this.onReady = callbacks.onReady;\r\n\r\n    const {onUpdate, hasEventListeners} = callbacks;\r\n    const config = new Configuration(options);\r\n\r\n    if (!config.sdkKey && !config.offline) {\r\n      throw new Error('You must configure the client with an SDK key');\r\n    }\r\n\r\n    if (!config.user) {\r\n      throw new Error('You must configure the client with a user');\r\n    }\r\n\r\n    this.config = config;\r\n    this.logger = config.logger;\r\n\r\n    this.init(platform, onUpdate, hasEventListeners);\r\n  }\r\n\r\n  private async init(platform: IPlatform, onUpdate: (keys: string[]) => void, hasEventListeners: () => boolean) {\r\n    const clientContext = new ClientContext(this.config.sdkKey, this.config, platform);\r\n    this.store = this.config.storeFactory(clientContext);\r\n    this.store.identify(this.config.user);\r\n    const dataSourceUpdates = new DataSourceUpdates(this.store, hasEventListeners, onUpdate);\r\n    this.evaluator = new Evaluator(this.store);\r\n\r\n    // use bootstrap provider to populate store\r\n    await this.config.bootstrapProvider.populate(this.config.user.keyId, dataSourceUpdates);\r\n\r\n    if (this.config.offline) {\r\n      this.eventProcessor = new NullEventProcessor();\r\n      this.dataSynchronizer = new NullDataSynchronizer();\r\n\r\n      this.initSuccess();\r\n    } else {\r\n      this.eventProcessor = new DefaultEventProcessor(clientContext);\r\n\r\n      const listeners = createStreamListeners(dataSourceUpdates, this.logger, {\r\n        put: () => this.initSuccess(),\r\n        patch: () => this.initSuccess()\r\n      });\r\n\r\n      const dataSynchronizer = this.config.dataSyncMode === DataSyncModeEnum.STREAMING\r\n        ? new WebSocketDataSynchronizer(\r\n          this.config.sdkKey,\r\n          this.config.user,\r\n          clientContext,\r\n          platform.webSocket,\r\n          () => this.store!.version,\r\n          listeners,\r\n          this.config.webSocketPingInterval\r\n        )\r\n        : new PollingDataSynchronizer(\r\n          this.config,\r\n          new Requestor(this.config.sdkKey, this.config, this.platform.info, this.platform.requests),\r\n          () => this.store!.version,\r\n          listeners,\r\n          (e) => this.dataSourceErrorHandler(e),\r\n        );\r\n\r\n      this.dataSynchronizer = this.config.dataSynchronizerFactory?.(\r\n        clientContext,\r\n        this.store,\r\n        dataSourceUpdates,\r\n        () => this.initSuccess(),\r\n        (e) => this.dataSourceErrorHandler(e),\r\n      ) ?? dataSynchronizer;\r\n    }\r\n\r\n    this.start();\r\n  }\r\n\r\n  identify(user: IUser) {\r\n    const validator = new UserValidator();\r\n    if (!validator.is(user)) {\r\n      validator.messages.forEach((error: string) => {\r\n        this.logger?.warn(error);\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    this.store!.identify(user);\r\n    this.dataSynchronizer!.identify(user);\r\n  }\r\n\r\n  private start() {\r\n    if (this.config.offline) {\r\n      return;\r\n    }\r\n\r\n    this.dataSynchronizer!.start();\r\n    setTimeout(() => {\r\n      if (!this.initialized()) {\r\n        const msg = `FbClient failed to start successfully within ${ this.config.startWaitTime } milliseconds. ` +\r\n          'This error usually indicates a connection issue with FeatBit or an invalid sdkKey.' +\r\n          'Please double-check your sdkKey and streamingUri/pollingUri configuration. ' +\r\n          'We will continue to initialize the FbClient, it still have a chance to get to work ' +\r\n          'if it\\'s a temporary network issue';\r\n\r\n        const error = new Error(msg);\r\n        this.state = ClientState.Failed;\r\n        this.rejectionReason = error;\r\n        this.initReject?.(error);\r\n\r\n        return this.logger?.warn(msg);\r\n      }\r\n    }, this.config.startWaitTime);\r\n  }\r\n\r\n  initialized(): boolean {\r\n    return this.state === ClientState.Initialized;\r\n  }\r\n\r\n  waitForInitialization(): Promise<IFbClientCore> {\r\n    // An initialization promise is only created if someone is going to use that promise.\r\n    // If we always created an initialization promise, and there was no call waitForInitialization\r\n    // by the time the promise was rejected, then that would result in an unhandled promise\r\n    // rejection.\r\n\r\n    // Initialization promise was created by a previous call to waitForInitialization.\r\n    if (this.initializedPromise) {\r\n      return this.initializedPromise;\r\n    }\r\n\r\n    // Initialization completed before waitForInitialization was called, so we have completed\r\n    // and there was no promise. So we make a resolved promise and return it.\r\n    if (this.state === ClientState.Initialized) {\r\n      this.initializedPromise = Promise.resolve(this);\r\n      return this.initializedPromise;\r\n    }\r\n\r\n    // Initialization failed before waitForInitialization was called, so we have completed\r\n    // and there was no promise. So we make a rejected promise and return it.\r\n    if (this.state === ClientState.Failed) {\r\n      this.initializedPromise = Promise.reject(this.rejectionReason);\r\n      return this.initializedPromise;\r\n    }\r\n\r\n    if (!this.initializedPromise) {\r\n      this.initializedPromise = new Promise((resolve, reject) => {\r\n        this.initResolve = resolve;\r\n        this.initReject = reject;\r\n      });\r\n    }\r\n    return this.initializedPromise;\r\n  }\r\n\r\n  boolVariation(\r\n    key: string,\r\n    defaultValue: boolean\r\n  ): boolean {\r\n    return this.evaluateCore(key, defaultValue, ValueConverters.bool).value!;\r\n  }\r\n\r\n  boolVariationDetail(\r\n    key: string,\r\n    defaultValue: boolean\r\n  ): IEvalDetail<boolean> {\r\n    return this.evaluateCore(key, defaultValue, ValueConverters.bool);\r\n  }\r\n\r\n  jsonVariation(key: string, defaultValue: any): any {\r\n    return this.evaluateCore(key, defaultValue, ValueConverters.json).value!;\r\n  }\r\n\r\n  jsonVariationDetail(key: string, defaultValue: any): IEvalDetail<any> {\r\n    return this.evaluateCore(key, defaultValue, ValueConverters.json);\r\n  }\r\n\r\n  numberVariation(key: string, defaultValue: number): number {\r\n    return this.evaluateCore(key, defaultValue, ValueConverters.number).value!;\r\n  }\r\n\r\n  numberVariationDetail(key: string, defaultValue: number): IEvalDetail<number> {\r\n    return this.evaluateCore(key, defaultValue, ValueConverters.number);\r\n  }\r\n\r\n  stringVariation(key: string, defaultValue: string): string {\r\n    return this.evaluateCore(key, defaultValue, ValueConverters.string).value!;\r\n  }\r\n\r\n  stringVariationDetail(key: string, defaultValue: string): IEvalDetail<string> {\r\n    return this.evaluateCore(key, defaultValue, ValueConverters.string);\r\n  }\r\n\r\n  variation(key: string, defaultValue: string): string {\r\n    return this.evaluateCore(key, defaultValue, ValueConverters.string).value!;\r\n  }\r\n\r\n  variationDetail(key: string, defaultValue: string): IEvalDetail<string> {\r\n    return this.evaluateCore(key, defaultValue, ValueConverters.string);\r\n  }\r\n\r\n  getAllVariations(): Promise<IEvalDetail<string>[]> {\r\n    const context = Context.fromUser(this.config.user);\r\n    if (!context.valid) {\r\n      const error = new ClientError(\r\n        `${ context.message ?? 'User not valid;' } returning default value.`,\r\n      );\r\n      this.onError(error);\r\n\r\n      return Promise.resolve([]);\r\n    }\r\n\r\n    const [flags, _] = this.store!.all(DataKinds.Flags);\r\n    const result = Object.keys(flags).map(flagKey => {\r\n      const evalResult = this.evaluator!.evaluate(flagKey);\r\n      return {flagKey, kind: evalResult.kind, reason: evalResult.reason, value: evalResult.value?.variation};\r\n    });\r\n\r\n    return Promise.resolve(result);\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    await this.eventProcessor!.close();\r\n    this.dataSynchronizer?.close();\r\n    this.store!.close();\r\n  }\r\n\r\n  track(eventName: string, metricValue?: number | undefined): void {\r\n    const metricEvent = new MetricEvent(this.config.user, eventName, this.platform.info.appType, metricValue ?? 1);\r\n    this.eventProcessor!.record(metricEvent);\r\n    return;\r\n  }\r\n\r\n  async flush(callback?: (res: boolean) => void): Promise<boolean> {\r\n    try {\r\n      await this.eventProcessor!.flush();\r\n      callback?.(true);\r\n      return true;\r\n    } catch (err) {\r\n      callback?.(false);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  evaluateCore<TValue>(\r\n    flagKey: string,\r\n    defaultValue: TValue,\r\n    typeConverter: (value: string) => IConvertResult<TValue>\r\n  ): IEvalDetail<TValue> {\r\n    const context = Context.fromUser(this.config.user);\r\n    if (!context.valid) {\r\n      const error = new ClientError(\r\n        `${ context.message ?? 'User not valid;' } returning default value.`,\r\n      );\r\n      this.onError(error);\r\n\r\n      return {flagKey, kind: ReasonKinds.Error, reason: error.message, value: defaultValue};\r\n    }\r\n\r\n    const evalResult = this.evaluator!.evaluate(flagKey);\r\n\r\n    if (evalResult.kind === ReasonKinds.FlagNotFound) {\r\n      // flag not found, return default value\r\n      const error = new ClientError(evalResult.reason!);\r\n      this.onError(error);\r\n\r\n      return {flagKey, kind: evalResult.kind, reason: evalResult.reason, value: defaultValue};\r\n    }\r\n\r\n    if (!this.initialized()) {\r\n      this.logger?.warn(\r\n        'Variation called before FeatBit client initialization completed (did you wait for the' +\r\n        \"'ready' event?)\",\r\n      );\r\n    } else {\r\n      // send event\r\n      this.eventProcessor!.record(evalResult.toEvalEvent(this.config.user));\r\n    }\r\n\r\n    const {isSucceeded, value} = typeConverter(evalResult.value?.variation!);\r\n    return isSucceeded\r\n      ? {flagKey, kind: evalResult.kind, reason: evalResult.reason, value}\r\n      : {flagKey, kind: ReasonKinds.WrongType, reason: 'type mismatch', value: defaultValue};\r\n  }\r\n\r\n  private dataSourceErrorHandler(e: any) {\r\n    const error =\r\n      e.code === 401 ? new Error('Authentication failed. Double check your SDK key.') : e;\r\n\r\n    this.onError(error);\r\n    this.onFailed(error);\r\n\r\n    if (!this.initialized()) {\r\n      this.state = ClientState.Failed;\r\n      this.rejectionReason = error;\r\n      this.initReject?.(error);\r\n    }\r\n  }\r\n\r\n  private initSuccess() {\r\n    if (!this.initialized()) {\r\n      this.state = ClientState.Initialized;\r\n      this.logger?.info('FbClient started successfully.');\r\n      this.initResolve?.(this);\r\n      this.onReady();\r\n    }\r\n  }\r\n}\r\n","import { IBootstrapProvider } from \"./IBootstrapProvider\";\r\nimport { deserializeAll } from \"../store/serialization\";\r\nimport { IDataSourceUpdates } from \"../store/IDataSourceUpdates\";\r\nimport { IStoreDataStorage } from \"../store/store\";\r\nimport { isNullOrUndefined } from \"../utils/isNullOrUndefined\";\r\nimport { IFlag, IFlagBase } from \"../evaluation/data/IFlag\";\r\n\r\nexport class JsonBootstrapProvider implements IBootstrapProvider {\r\n  private dataSet?: IStoreDataStorage;\r\n\r\n  constructor(bootstrap: IFlagBase[]) {\r\n    const flags: IFlag[] = (bootstrap || []).map((flag: IFlagBase) => ({...flag, variationOptions: flag.variationOptions || [{id: null, variation: flag.variation}]})) as IFlag[];\r\n\r\n    const data = deserializeAll(flags);\r\n    this.dataSet = {\r\n      flags: data.flags,\r\n      version: 0\r\n    };\r\n  }\r\n\r\n  populate(userKeyId: string, dataSourceUpdates: IDataSourceUpdates, callback?: () => void): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (isNullOrUndefined(this.dataSet)) {\r\n        return resolve();\r\n      }\r\n\r\n      const internalCallback = () => {\r\n        resolve();\r\n        callback?.();\r\n      }\r\n\r\n      dataSourceUpdates.init(userKeyId, this.dataSet!, internalCallback);\r\n    });\r\n  }\r\n}","import { IBootstrapProvider } from \"./IBootstrapProvider\";\r\nimport { IDataSourceUpdates } from \"../store/IDataSourceUpdates\";\r\nimport { IStoreDataStorage } from \"../store/store\";\r\n\r\nexport class NullBootstrapProvider implements IBootstrapProvider {\r\n  private dataSet?: IStoreDataStorage;\r\n\r\n  constructor() {\r\n    this.dataSet = {\r\n      flags: {},\r\n      version: 0\r\n    };\r\n  }\r\n\r\n  populate(userKeyId: string, dataSourceUpdates: IDataSourceUpdates, callback?: () => void): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      resolve();\r\n      callback?.();\r\n    });\r\n  }\r\n}","export * from './IBootstrapProvider';\r\nexport * from './JsonBootstrapProvider';\r\nexport * from './NullBootstrapProvider';","export const EmptyString = '';\r\nexport const MinInt: number = 0x80000000;","import { IDataSourceUpdates } from \"../store/IDataSourceUpdates\";\r\nimport {\r\n  IStoreDataStorage,\r\n  IStoreItem,\r\n  IKeyedStoreItem\r\n} from \"../store/store\";\r\nimport { IStore } from \"../platform/IStore\";\r\nimport { IDataKind } from \"../IDataKind\";\r\nimport DataKinds from \"../store/DataKinds\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport default class DataSourceUpdates implements IDataSourceUpdates {\r\n\r\n  constructor(\r\n    private readonly store: IStore,\r\n    private readonly hasEventListeners: () => boolean,\r\n    private readonly onChange: (keys: string[]) => void,\r\n  ) {\r\n  }\r\n\r\n  init(userKeyId: string, allData: IStoreDataStorage, callback?: () => void): void {\r\n    if (userKeyId !== this.store.user.keyId) {\r\n      callback?.();\r\n      return;\r\n    }\r\n\r\n    const checkForChanges = this.hasEventListeners();\r\n    const doInit = (oldData?: IStoreDataStorage) => {\r\n      this.store.init(allData, () => {\r\n        // Defer change events so they execute after the callback.\r\n        Promise.resolve().then(() => {\r\n          if (checkForChanges) {\r\n            const updatedKeys = Object.keys(allData)\r\n              .flatMap((namespace) => {\r\n                const oldDataForKind = oldData?.[namespace] || {};\r\n                const newDataForKind = allData[namespace];\r\n                const mergedData = {...oldDataForKind, ...newDataForKind};\r\n                return Object.keys(mergedData)\r\n                  .filter((key: string) => this.isUpdated(oldDataForKind && oldDataForKind[key], newDataForKind && newDataForKind[key]));\r\n              });\r\n            updatedKeys.length > 0 && this.onChange(updatedKeys);\r\n          }\r\n        });\r\n        callback?.();\r\n      });\r\n    };\r\n\r\n    if (checkForChanges) {\r\n      const [flags, version] = this.store.all(DataKinds.Flags);\r\n      const oldData = {\r\n        flags,\r\n        version\r\n      };\r\n      doInit(oldData);\r\n    } else {\r\n      doInit();\r\n    }\r\n  }\r\n\r\n  upsert(userKeyId: string, kind: IDataKind, data: IKeyedStoreItem, callback: () => void): void {\r\n    if (userKeyId !== this.store.user.keyId) {\r\n      callback?.();\r\n      return;\r\n    }\r\n\r\n    const {key} = data;\r\n    const checkForChanges = this.hasEventListeners();\r\n    const doUpsert = (oldItem?: IStoreItem) => {\r\n      this.store.upsert(kind, data, () => {\r\n        // Defer change events so they execute after the callback.\r\n        Promise.resolve().then(() => {\r\n          if (checkForChanges && this.isUpdated(oldItem, data[key])) {\r\n            this.onChange([key]);\r\n          }\r\n        });\r\n\r\n        callback?.();\r\n      });\r\n    };\r\n    if (checkForChanges) {\r\n      const item = this.store.get(kind, key);\r\n      doUpsert(item || undefined);\r\n    } else {\r\n      doUpsert();\r\n    }\r\n  }\r\n\r\n  private isUpdated(oldData?: IStoreItem, newData?: IStoreItem): boolean {\r\n    return !oldData || !newData || newData.version > oldData.version\r\n  }\r\n}","/**\r\n * @internal\r\n */\r\nexport default class NamespacedDataSet<T> {\r\n  private itemsByNamespace: Record<string, Record<string, T>> = {};\r\n\r\n  get(namespace: string, key: string): T | undefined {\r\n    return this.itemsByNamespace[namespace]?.[key];\r\n  }\r\n\r\n  set(namespace: string, key: string, value: T) {\r\n    if (!(namespace in this.itemsByNamespace)) {\r\n      this.itemsByNamespace[namespace] = {};\r\n    }\r\n    this.itemsByNamespace[namespace][key] = value;\r\n  }\r\n\r\n  remove(namespace: string, key: string) {\r\n    const items = this.itemsByNamespace[namespace];\r\n    if (items) {\r\n      delete items[key];\r\n    }\r\n  }\r\n\r\n  removeAll() {\r\n    this.itemsByNamespace = {};\r\n  }\r\n\r\n  enumerate(callback: (namespace: string, key: string, value: T) => void) {\r\n    Object.entries(this.itemsByNamespace).forEach(([namespace, values]) => {\r\n      Object.entries(values).forEach(([key, value]) => {\r\n        callback(namespace, key, value);\r\n      });\r\n    });\r\n  }\r\n\r\n  mergeFrom(other: NamespacedDataSet<T>) {\r\n    other.enumerate(this.set.bind(this));\r\n  }\r\n}\r\n","import { IDataSourceUpdates } from \"../store/IDataSourceUpdates\";\r\nimport { ILogger } from \"../logging/ILogger\";\r\nimport { VoidFunction } from \"../utils/VoidFunction\";\r\nimport {\r\n  deserializeAll,\r\n  deserializePatch,\r\n  IPatchData,\r\n  Flags\r\n} from \"../store/serialization\";\r\nimport DataKinds from \"../store/DataKinds\";\r\nimport { IStoreDataStorage } from \"../store/store\";\r\nimport { EventName, ProcessStreamResponse } from \"../data-sync/types\";\r\n\r\nexport const createPutListener = (\r\n  dataSourceUpdates: IDataSourceUpdates,\r\n  logger?: ILogger,\r\n  onPutCompleteHandler: VoidFunction = () => {\r\n  },\r\n) => ({\r\n  deserializeData: deserializeAll,\r\n  processJson: async (userKeyId: string, {flags}: Flags) => {\r\n    const initData: IStoreDataStorage = {\r\n      flags: flags,\r\n      version: 0\r\n    };\r\n\r\n    logger?.debug('Initializing all data');\r\n    dataSourceUpdates.init(userKeyId, initData, onPutCompleteHandler);\r\n  },\r\n});\r\n\r\nexport const createPatchListener = (\r\n  dataSourceUpdates: IDataSourceUpdates,\r\n  logger?: ILogger,\r\n  onPatchCompleteHandler: VoidFunction = () => {\r\n  },\r\n) => ({\r\n  deserializeData: deserializePatch,\r\n  processJson: async (userKeyId: string, data: IPatchData[]) => {\r\n    if (data?.length === 0) {\r\n      onPatchCompleteHandler?.();\r\n      return;\r\n    }\r\n\r\n    data?.forEach(item => {\r\n      logger?.debug(`Updating ${ item.data.key } in ${ item.kind.namespace }`);\r\n      dataSourceUpdates.upsert(userKeyId, item.kind, item.data, onPatchCompleteHandler);\r\n    })\r\n  },\r\n});\r\n\r\n\r\nexport const createStreamListeners = (\r\n  dataSourceUpdates: IDataSourceUpdates,\r\n  logger?: ILogger,\r\n  onCompleteHandlers?: {\r\n    put?: VoidFunction;\r\n    patch?: VoidFunction;\r\n    delete?: VoidFunction;\r\n  },\r\n) => {\r\n  const listeners = new Map<EventName, ProcessStreamResponse>();\r\n  listeners.set('put', createPutListener(dataSourceUpdates, logger, onCompleteHandlers?.put));\r\n  listeners.set('patch', createPatchListener(dataSourceUpdates, logger, onCompleteHandlers?.patch));\r\n  return listeners;\r\n};\r\n","export * from './createStreamListeners';\r\nexport * from './DataSourceUpdates';\r\nexport * from './NamespacedDataSet';","export enum DataSyncModeEnum {\r\n  POLLING = 'polling',\r\n  STREAMING = 'streaming'\r\n}","import { IDataSynchronizer } from \"./IDataSynchronizer\";\r\n\r\nexport class NullDataSynchronizer implements IDataSynchronizer {\r\n  close(): void {\r\n  }\r\n\r\n  start(): void {\r\n  }\r\n\r\n  stop(): void {\r\n  }\r\n\r\n  identify(): void {\r\n  }\r\n}","import { isHttpRecoverable, PollingError } from \"../errors\";\r\nimport { IDataSynchronizer } from \"./IDataSynchronizer\";\r\nimport { ILogger } from \"../logging/ILogger\";\r\nimport Configuration from \"../Configuration\";\r\nimport { EventName, PollingErrorHandler, ProcessStreamResponse, StreamResponseEventType } from \"./types\";\r\nimport Requestor from \"./Requestor\";\r\nimport { httpErrorMessage } from \"../utils/http\";\r\nimport { IUser } from \"../options/IUser\";\r\n\r\nexport default class PollingDataSynchronizer implements IDataSynchronizer {\r\n  private stopped = false;\r\n\r\n  private logger?: ILogger;\r\n\r\n  private pollingInterval: number;\r\n\r\n  private user: IUser | undefined;\r\n\r\n  private timeoutHandle: any;\r\n\r\n  constructor(\r\n    config: Configuration,\r\n    private readonly requestor: Requestor,\r\n    private readonly getStoreTimestamp: () => number,\r\n    private readonly listeners: Map<EventName, ProcessStreamResponse>,\r\n    private readonly errorHandler?: PollingErrorHandler,\r\n  ) {\r\n    this.logger = config.logger;\r\n    this.pollingInterval = config.pollingInterval;\r\n    this.user = config.user;\r\n  }\r\n\r\n  private poll() {\r\n    if (this.stopped) {\r\n      return;\r\n    }\r\n\r\n    const startTime = Date.now();\r\n    this.logger?.debug('Polling for feature flag and segments updates');\r\n    this.requestor.requestData(this.getStoreTimestamp(), this.user, (err, body) => {\r\n      const elapsed = Date.now() - startTime;\r\n      const sleepFor = Math.max(this.pollingInterval - elapsed, 0);\r\n\r\n      this.logger?.debug('Elapsed: %d ms, sleeping for %d ms', elapsed, sleepFor);\r\n      if (err) {\r\n        const {status} = err;\r\n        if (status && !isHttpRecoverable(status)) {\r\n          const message = httpErrorMessage(err, 'polling request');\r\n          this.logger?.error(message);\r\n          this.errorHandler?.(new PollingError(message, status));\r\n          // It is not recoverable, return and do not trigger another\r\n          // poll.\r\n          return;\r\n        }\r\n        this.logger?.warn(httpErrorMessage(err, 'polling request', 'will retry'));\r\n      } else {\r\n        let featureFlags = [];\r\n        let userKeyId = this.user?.keyId!;\r\n        let processStreamResponse: ProcessStreamResponse | undefined = this.listeners.get('patch');\r\n\r\n        if (body) {\r\n          const message = JSON.parse(body);\r\n          if (message.messageType === 'data-sync') {\r\n            switch (message.data.eventType) {\r\n              case StreamResponseEventType.patch:\r\n                processStreamResponse = this.listeners.get('patch');\r\n                break;\r\n              case StreamResponseEventType.full:\r\n                processStreamResponse = this.listeners.get('put');\r\n                break;\r\n            }\r\n\r\n            ({featureFlags, userKeyId} = message.data);\r\n          }\r\n        }\r\n\r\n        const data = processStreamResponse?.deserializeData?.(featureFlags);\r\n        processStreamResponse?.processJson?.(userKeyId, data);\r\n      }\r\n\r\n      // Falling through, there was some type of error and we need to trigger\r\n      // a new poll.\r\n      this.timeoutHandle = setTimeout(() => {\r\n        this.poll();\r\n      }, sleepFor);\r\n    });\r\n  }\r\n\r\n  identify(user: IUser) {\r\n    this.user = {...user};\r\n  }\r\n\r\n  close(): void {\r\n    this.stop();\r\n  }\r\n\r\n  start(): void {\r\n    this.poll();\r\n  }\r\n\r\n  stop(): void {\r\n    if (this.timeoutHandle) {\r\n      clearTimeout(this.timeoutHandle);\r\n      this.timeoutHandle = undefined;\r\n    }\r\n    this.stopped = true;\r\n  }\r\n}\r\n\r\n\r\n\r\n","import { IRequestor } from \"./IRequestor\";\r\nimport Configuration from \"../Configuration\";\r\nimport { IInfo } from \"../platform/IInfo\";\r\nimport { IRequestOptions, IRequests, IResponse } from \"../platform/requests\";\r\nimport { StreamingError } from \"../errors\";\r\nimport { defaultHeaders } from \"../utils/http\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport default class Requestor implements IRequestor {\r\n  private readonly headers: Record<string, string>;\r\n\r\n  private readonly uri: string;\r\n\r\n  constructor(\r\n    sdkKey: string,\r\n    config: Configuration,\r\n    info: IInfo,\r\n    private readonly requests: IRequests,\r\n  ) {\r\n    this.headers = defaultHeaders(sdkKey, info);\r\n    this.uri = config.pollingUri;\r\n  }\r\n\r\n  /**\r\n   * Perform a request and utilize the ETag cache. The ETags are cached in the\r\n   * requestor instance.\r\n   */\r\n  private async request(\r\n    requestUrl: string,\r\n    options: IRequestOptions,\r\n  ): Promise<{\r\n    res: IResponse;\r\n    body: string;\r\n  }> {\r\n    const res = await this.requests.fetch(requestUrl, options);\r\n\r\n    const body = await res.text();\r\n\r\n    return {res, body};\r\n  }\r\n\r\n  async requestData(timestamp: number, payload: any, cb: (err: any, body: any) => void) {\r\n    const options: IRequestOptions = {\r\n      method: 'POST',\r\n      headers: this.headers,\r\n      body: JSON.stringify(payload)\r\n    };\r\n    try {\r\n      const {res, body} = await this.request(`${ this.uri }?timestamp=${ timestamp ?? 0 }`, options);\r\n      if (res.status !== 200 && res.status !== 304) {\r\n        const err = new StreamingError(`Unexpected status code: ${ res.status }`, res.status);\r\n        return cb(err, undefined);\r\n      }\r\n      return cb(undefined, res.status === 304 ? null : body);\r\n    } catch (err) {\r\n      return cb(err, undefined);\r\n    }\r\n  }\r\n}\r\n","import { IDataSynchronizer } from \"./IDataSynchronizer\";\r\nimport ClientContext from \"../options/ClientContext\";\r\nimport { EventName, ProcessStreamResponse } from \"./types\";\r\nimport { ILogger } from \"../logging/ILogger\";\r\nimport { IWebSocketWithEvents } from \"../platform/IWebSocket\";\r\nimport { IUser } from \"../options/IUser\";\r\n\r\nclass WebSocketDataSynchronizer implements IDataSynchronizer {\r\n  private socket?: IWebSocketWithEvents;\r\n  private readonly logger?: ILogger;\r\n\r\n  private connectionAttemptStartTime?: number;\r\n\r\n  constructor(\r\n    sdkKey: string,\r\n    user: IUser,\r\n    clientContext: ClientContext,\r\n    socket: IWebSocketWithEvents,\r\n    private readonly getStoreTimestamp: () => number,\r\n    private readonly listeners: Map<EventName, ProcessStreamResponse>,\r\n    webSocketPingInterval: number\r\n  ) {\r\n    const {logger, streamingUri} = clientContext;\r\n\r\n    this.logger = logger;\r\n    this.socket = socket;\r\n    this.socket.config({\r\n      sdkKey,\r\n      streamingUri,\r\n      pingInterval: webSocketPingInterval,\r\n      user,\r\n      logger,\r\n      getStoreTimestamp\r\n    });\r\n\r\n    this.listeners.forEach(({deserializeData, processJson}, eventName) => {\r\n      this.socket?.addListener(eventName, (event) => {\r\n        this.logger?.debug(`Received ${ eventName } event`);\r\n\r\n        if (event?.data) {\r\n          const {featureFlags, userKeyId} = event.data;\r\n          const data = deserializeData(featureFlags);\r\n          processJson(userKeyId, data);\r\n        }\r\n      });\r\n    })\r\n  }\r\n\r\n  identify(user: IUser): void {\r\n    this.socket?.identify(user);\r\n  }\r\n\r\n  start(): void {\r\n    this.logConnectionStarted();\r\n\r\n    this.socket?.connect();\r\n  }\r\n\r\n  private logConnectionStarted() {\r\n    this.connectionAttemptStartTime = Date.now();\r\n    this.logger?.info(`Stream connection attempt StartTime ${ this.connectionAttemptStartTime }`);\r\n  }\r\n\r\n  close(): void {\r\n    this.stop();\r\n  }\r\n\r\n  stop(): void {\r\n    this.socket?.close();\r\n    this.socket = undefined;\r\n  }\r\n}\r\n\r\nexport default WebSocketDataSynchronizer;","export * from './DataSyncMode';\r\nexport * from './IDataSynchronizer';\r\nexport * from './IRequestor';\r\nexport * from './NullDataSynchronizer';\r\nexport * from './PollingDataSynchronizer';\r\nexport * from './Requestor';\r\nexport * from './types';\r\nexport * from './utils';\r\nexport * from './WebSocketDataSynchronizer';","import { PollingError } from \"../errors\";\r\nimport { IFlag } from \"../evaluation/data/IFlag\";\r\n\r\nexport type PollingErrorHandler = (err: PollingError) => void;\r\n\r\nexport enum StreamResponseEventType {\r\n  full = 'full',\r\n  patch = 'patch'\r\n}\r\n\r\nexport interface IStreamResponse {\r\n  eventType: StreamResponseEventType,\r\n  featureFlags: IFlag[]\r\n}\r\n\r\nexport type EventName = 'delete' | 'patch' | 'ping' | 'put';\r\nexport type ProcessStreamResponse = {\r\n  deserializeData: (flags: IFlag[]) => any;\r\n  processJson: (userKeyId: string, json: any) => void;\r\n};","/********************** encode text begin *****************************/\r\nconst alphabet: Record<string, string> = {\r\n  \"0\": \"Q\",\r\n  \"1\": \"B\",\r\n  \"2\": \"W\",\r\n  \"3\": \"S\",\r\n  \"4\": \"P\",\r\n  \"5\": \"H\",\r\n  \"6\": \"D\",\r\n  \"7\": \"X\",\r\n  \"8\": \"Z\",\r\n  \"9\": \"U\",\r\n}\r\n\r\nfunction encodeNumber(param: number, length: number): string {\r\n  var s = \"000000000000\" + param;\r\n  const numberWithLeadingZeros = s.slice(s.length - length);\r\n  return numberWithLeadingZeros.split('').map(n => alphabet[n]).join('');\r\n}\r\n\r\n// generate connection token\r\nexport function generateConnectionToken(text: string): string {\r\n  text = text.replace(/=*$/, '');\r\n  const timestamp = Date.now();\r\n  const timestampCode = encodeNumber(timestamp, timestamp.toString().length);\r\n  // get random number less than the length of the text as the start point, and it must be greater or equal to 2\r\n  const start = Math.max(Math.floor(Math.random() * text.length), 2);\r\n\r\n  return `${ encodeNumber(start, 3) }${ encodeNumber(timestampCode.length, 2) }${ text.slice(0, start) }${ timestampCode }${ text.slice(start) }`;\r\n}\r\n\r\n/********************** encode text end *****************************/","export class PollingError extends Error {\r\n  public readonly status?: number;\r\n\r\n  constructor(message: string, status?: number) {\r\n    super(message);\r\n    this.status = status;\r\n    this.name = 'FbPollingError';\r\n  }\r\n}\r\n\r\nexport class StreamingError extends Error {\r\n  public readonly code?: number;\r\n\r\n  constructor(message: string, code?: number) {\r\n    super(message);\r\n    this.code = code;\r\n    this.name = 'FbStreamingError';\r\n  }\r\n}\r\n\r\nexport class UnexpectedResponseError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'FbUnexpectedResponseError';\r\n  }\r\n}\r\n\r\n\r\nexport class ClientError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'FbClientError';\r\n  }\r\n}\r\n\r\nexport function isHttpRecoverable(status: number) {\r\n  if (status >= 400 && status < 500) {\r\n    return status === 400 || status === 408 || status === 429;\r\n  }\r\n  return true;\r\n}","import { ReasonKinds } from \"./ReasonKinds\";\r\nimport { IFlag } from \"./data/IFlag\";\r\nimport { EvalEvent } from \"../events/event\";\r\nimport { IUser } from \"../options/IUser\";\r\n\r\n/**\r\n * A class which encapsulates the result of an evaluation. It allows for differentiating between\r\n * successful and error result types.\r\n *\r\n * @internal\r\n */\r\nexport default class EvalResult {\r\n  protected constructor(\r\n    public kind: ReasonKinds,\r\n    public value: IFlag | null,\r\n    public reason?: string,\r\n  ) {\r\n  }\r\n\r\n  static flagNotFound(flagKey: string) {\r\n    return new EvalResult(ReasonKinds.FlagNotFound, null, `flag not found: ${ flagKey }`);\r\n  }\r\n\r\n  static matched(val: IFlag) {\r\n    return new EvalResult(ReasonKinds.Match, val, 'target match');\r\n  }\r\n\r\n  toEvalEvent(user: IUser): EvalEvent | null {\r\n    if (this.kind !== ReasonKinds.Match) {\r\n      return null;\r\n    }\r\n\r\n    const targetedVariation = this.value?.variations.find(v => v.value === this.value?.variation);\r\n    return new EvalEvent(user, this.value?.id!, targetedVariation!, this.value?.sendToExperiment!);\r\n  }\r\n}","import { IFlag } from \"./data/IFlag\";\r\nimport EvalResult from \"./EvalResult\";\r\nimport { IStore } from \"../platform/IStore\";\r\nimport DataKinds from \"../store/DataKinds\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport default class Evaluator {\r\n  constructor(private store: IStore) {\r\n  }\r\n\r\n  /**\r\n   * Evaluate the given flag against the given context.\r\n   * @param flagKey The key of the feature flag.\r\n   */\r\n  evaluate(\r\n    flagKey: string,\r\n  ): EvalResult {\r\n    const flag = this.store.get(DataKinds.Flags, flagKey) as unknown as IFlag;\r\n    if (!flag) {\r\n      return EvalResult.flagNotFound(flagKey);\r\n    }\r\n\r\n    return EvalResult.matched(flag);\r\n  }\r\n}","/**\r\n * Different kinds of error which may be encountered during evaluation.\r\n */\r\nexport enum ReasonKinds {\r\n  ClientNotReady = 'ClientNotReady',\r\n  Match = 'Match',\r\n  WrongType = 'WrongType',\r\n  FlagNotFound = 'FlagNotFound',\r\n  Error = 'Error'\r\n}","export type FlagValue = any;\r\n\r\nexport enum VariationDataType {\r\n  string = 'string',\r\n  boolean = 'boolean',\r\n  number = 'number',\r\n  json = 'json',\r\n  empty = ''\r\n}\r\n\r\nexport interface IVariation {\r\n  id: number,\r\n  value: FlagValue\r\n}\r\n\r\nexport interface IFlagBase {\r\n  id: string, // the key\r\n  variation: FlagValue,\r\n  variationType: VariationDataType,\r\n  sendToExperiment?: boolean,\r\n  timestamp?: number,\r\n  variationOptions?: IVariation[],\r\n}\r\n\r\nexport interface IFlag extends IFlagBase {\r\n  key: string, // the same value to id\r\n  variations: IVariation[],// the same value to variationOptions\r\n  version: number\r\n}\r\n","export * from './IFlag';","export * from './data';\r\nexport * from './EvalResult';\r\nexport * from './Evaluator';\r\nexport * from './IEvalDetail';\r\nexport * from './operator';\r\nexport * from './ReasonKinds';","import { Regex } from \"../utils/Regex\";\r\n\r\nexport enum OperatorTypes {\r\n  // numeric\r\n  LessThan = \"LessThan\",\r\n  BiggerThan = \"BiggerThan\",\r\n  LessEqualThan = \"LessEqualThan\",\r\n  BiggerEqualThan = \"BiggerEqualThan\",\r\n\r\n  // compare\r\n  Equal = \"Equal\",\r\n  NotEqual = \"NotEqual\",\r\n\r\n  // contains/not contains\r\n  Contains = \"Contains\",\r\n  NotContain = \"NotContain\",\r\n\r\n  // starts with/ends with\r\n  StartsWith = \"StartsWith\",\r\n  EndsWith = \"EndsWith\",\r\n\r\n  // match regex/not match regex\r\n  MatchRegex = \"MatchRegex\",\r\n  NotMatchRegex = \"NotMatchRegex\",\r\n\r\n  // is one of/ not one of\r\n  IsOneOf = \"IsOneOf\",\r\n  NotOneOf = \"NotOneOf\",\r\n\r\n  // is true/ is false\r\n  IsTrue = \"IsTrue\",\r\n  IsFalse = \"IsFalse\",\r\n}\r\n\r\nexport class Operator {\r\n\r\n  constructor(private readonly operation: string, private readonly func: (param1: string, param2: string) => boolean) {\r\n  }\r\n\r\n  public isMatch(value: string, conditionValue: string) {\r\n    if (value === null || conditionValue === null) {\r\n      return false;\r\n    }\r\n\r\n    return this.func(value, conditionValue);\r\n  }\r\n\r\n  /***************** numeric ********************/\r\n  public static readonly LessThan: Operator =\r\n    new Operator(OperatorTypes.LessThan, Operator.numericOperator(-1, -1));\r\n\r\n  public static readonly LessEqualThan: Operator =\r\n    new Operator(OperatorTypes.LessEqualThan, Operator.numericOperator(-1, 0));\r\n\r\n  public static readonly BiggerThan: Operator =\r\n    new Operator(OperatorTypes.BiggerThan, Operator.numericOperator(1, 1));\r\n\r\n  public static readonly BiggerEqualThan: Operator =\r\n    new Operator(OperatorTypes.BiggerEqualThan, Operator.numericOperator(1, 0));\r\n\r\n\r\n  private static numericOperator(\r\n    desiredComparisonResult: number,\r\n    otherDesiredComparisonResult: number): (param1: string, param2: string) => boolean {\r\n    return (param1: string, param2: string) => {\r\n      const param1FloatValue = parseFloat(param1);\r\n      const param2FloatValue = parseFloat(param2);\r\n\r\n      // Check if parsing fails or if values are NaN\r\n      if (isNaN(param1FloatValue) || isNaN(param2FloatValue)) {\r\n        return false;\r\n      }\r\n\r\n      // Compare the parsed double values and return true if the result matches\r\n      const result = Math.sign(param1FloatValue - param2FloatValue);\r\n      return result === desiredComparisonResult || result === otherDesiredComparisonResult;\r\n    }\r\n  }\r\n\r\n  /*********************** string compare *******************************/\r\n  public static readonly Equal: Operator =\r\n    new Operator(OperatorTypes.Equal, (param1: string, param2: string) => param1 === param2);\r\n\r\n  public static readonly NotEqual: Operator =\r\n    new Operator(OperatorTypes.NotEqual, (param1: string, param2: string) => param1 !== param2);\r\n\r\n  /*********************** string contains/not contains *******************************/\r\n  public static readonly Contains: Operator =\r\n    new Operator(OperatorTypes.Contains, (param1: string, param2: string) => param1.includes(param2));\r\n\r\n  public static readonly NotContains: Operator =\r\n    new Operator(OperatorTypes.NotContain, (param1: string, param2: string) => !param1.includes(param2));\r\n\r\n  /*********************** string starts with/end with *******************************/\r\n  public static readonly StartsWith: Operator =\r\n    new Operator(OperatorTypes.StartsWith, (param1: string, param2: string) => param1.startsWith(param2));\r\n\r\n  public static readonly EndsWith: Operator =\r\n    new Operator(OperatorTypes.EndsWith, (param1: string, param2: string) => param1.endsWith(param2));\r\n\r\n  /*********************** regex *******************************/\r\n  public static readonly MatchRegex: Operator =\r\n    new Operator(OperatorTypes.MatchRegex, (pattern: string, param2: string) => Regex.fromString(pattern).test(param2));\r\n\r\n  public static readonly NotMatchRegex: Operator =\r\n    new Operator(OperatorTypes.NotMatchRegex, (pattern: string, param2: string) => !Regex.fromString(pattern).test(param2));\r\n\r\n  /*********************** is one of/ not one of *******************************/\r\n  public static readonly IsOneOf: Operator =\r\n    new Operator(OperatorTypes.IsOneOf, (param1: string, param2: string) => {\r\n      try {\r\n        const values: string[] = JSON.parse(param2);\r\n        return values.includes(param1);\r\n      } catch (e) {\r\n        return false;\r\n      }\r\n    });\r\n\r\n  public static readonly NotOneOf: Operator =\r\n    new Operator(OperatorTypes.NotOneOf, (param1: string, param2: string) => {\r\n      try {\r\n        const values: string[] = JSON.parse(param2);\r\n        return !values.includes(param1);\r\n      } catch (e) {\r\n        return false;\r\n      }\r\n    });\r\n\r\n  /*********************** is true/ is false *******************************/\r\n  public static readonly IsTrue: Operator =\r\n    new Operator(OperatorTypes.IsTrue, (param1: string, _: string) => param1?.toUpperCase() === 'TRUE');\r\n\r\n  public static readonly IsFalse: Operator =\r\n    new Operator(OperatorTypes.IsFalse, (param1: string, _: string) => param1?.toUpperCase() === 'FALSE');\r\n\r\n  public static All = [\r\n    // numeric\r\n    Operator.LessThan, Operator.LessEqualThan, Operator.BiggerThan, Operator.BiggerEqualThan,\r\n\r\n    // string compare\r\n    Operator.Equal, Operator.NotEqual,\r\n\r\n    // string contains/not contains\r\n    Operator.Contains, Operator.NotContains,\r\n\r\n    // string starts with/ends with\r\n    Operator.StartsWith, Operator.EndsWith,\r\n\r\n    // string match regex/not match regex\r\n    Operator.MatchRegex, Operator.NotMatchRegex,\r\n\r\n    // is one of/ not one of\r\n    Operator.IsOneOf, Operator.NotOneOf,\r\n\r\n    // is true/ is false\r\n    Operator.IsTrue, Operator.IsFalse\r\n  ]\r\n\r\n  public static get(operation: string) {\r\n    const op = Operator.All.find(o => o.operation === operation);\r\n\r\n    return op ?? new Operator(operation, (param1: string, param2: string) => false);\r\n  }\r\n}","import { IEventProcessor } from \"./IEventProcessor\";\r\nimport { EventDispatcher } from \"./EventDispatcher\";\r\nimport ClientContext from \"../options/ClientContext\";\r\nimport { FlushEvent, IEvent, ShutdownEvent } from \"./event\";\r\nimport { isNullOrUndefined } from \"../utils/isNullOrUndefined\";\r\nimport { IEventQueue } from \"./IEventQueue\";\r\nimport { DefaultEventQueue } from \"./DefaultEventQueue\";\r\nimport { ILogger } from \"../logging/ILogger\";\r\n\r\nexport class DefaultEventProcessor implements IEventProcessor {\r\n  private readonly logger: ILogger;\r\n  private readonly flushInterval: number;\r\n  private readonly eventDispatcher: EventDispatcher;\r\n  private readonly eventQueue: IEventQueue;\r\n  private closed: boolean = false;\r\n\r\n  constructor(clientContext: ClientContext) {\r\n    const {logger, flushInterval, maxEventsInQueue} = clientContext;\r\n    this.logger = logger!;\r\n    this.flushInterval = flushInterval;\r\n    this.eventQueue = new DefaultEventQueue(maxEventsInQueue, this.logger);\r\n    this.eventDispatcher = new EventDispatcher(clientContext, this.eventQueue);\r\n\r\n    this.flushLoop();\r\n  }\r\n\r\n  private flushLoop() {\r\n    if (this.closed) {\r\n      return;\r\n    }\r\n\r\n    setTimeout(async () => {\r\n      try {\r\n        await this.flush();\r\n      } catch (err) {\r\n        this.logger.error('Unexpected error while flushing events in event processor.', err);\r\n      }\r\n\r\n      this.flushLoop();\r\n    }, this.flushInterval);\r\n  }\r\n\r\n  flush(): Promise<any> {\r\n    const flushEvent = new FlushEvent();\r\n    this.record(flushEvent);\r\n    return flushEvent.waitForCompletion();\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    if (this.closed) {\r\n      return;\r\n    }\r\n\r\n    // send a shutdown event to dispatcher\r\n    const shutdown = new ShutdownEvent();\r\n    this.record(shutdown);\r\n\r\n    try {\r\n      await shutdown.waitForCompletion();\r\n    } catch (err) {\r\n      this.logger.error('Event processor shutdown but not complete.');\r\n    }\r\n\r\n    // mark the event queue as complete for adding\r\n    this.eventQueue.close();\r\n    this.closed = true;\r\n  }\r\n\r\n  record(event: IEvent | null): boolean {\r\n    if (isNullOrUndefined(event)) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.eventQueue.addEvent(event!)) {\r\n      if (event instanceof FlushEvent) {\r\n        event.complete();\r\n      }\r\n\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n}","import { IEventQueue } from \"./IEventQueue\";\r\nimport { IEvent } from \"./event\";\r\nimport { ILogger } from \"../logging/ILogger\";\r\n\r\nexport class DefaultEventQueue implements IEventQueue {\r\n  private events: IEvent[];\r\n  private closed: boolean = false;\r\n\r\n  constructor(private readonly capacity: number, private readonly logger: ILogger) {\r\n    this.events = [];\r\n  }\r\n\r\n  addEvent(event: IEvent): boolean {\r\n    if (this.closed) {\r\n      return false;\r\n    }\r\n\r\n    if (this.events.length >= this.capacity) {\r\n      this.logger.warn(\"Events are being produced faster than they can be processed. We shouldn't see this.\");\r\n      return false;\r\n    }\r\n\r\n    this.events.push(event);\r\n    return true;\r\n  }\r\n\r\n  clear(): void {\r\n    this.events = [];\r\n  }\r\n\r\n  shift(): IEvent | undefined {\r\n    return this.events.shift();\r\n  }\r\n\r\n  close(): void {\r\n    this.closed = true;\r\n  }\r\n\r\n  get eventsSnapshot(): IEvent[] {\r\n    return [...this.events];\r\n  }\r\n\r\n  get length(): number {\r\n    return this.events.length;\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return this.length === 0;\r\n  }\r\n}","import { DeliveryStatus, IEventSender, IEventSenderResult } from \"./IEventSender\";\r\nimport ClientContext from \"../options/ClientContext\";\r\nimport { defaultHeaders, httpErrorMessage } from \"../utils/http\";\r\nimport { IRequests } from \"../platform/requests\";\r\nimport { isHttpRecoverable, UnexpectedResponseError } from \"../errors\";\r\nimport sleep from \"../utils/sleep\";\r\n\r\nexport class DefaultEventSender implements IEventSender {\r\n  private readonly defaultHeaders: {\r\n    [key: string]: string;\r\n  };\r\n  private readonly eventsUri: string;\r\n  private requests: IRequests;\r\n\r\n  constructor(clientContext: ClientContext) {\r\n    const {\r\n      sdkKey,\r\n      eventsUri,\r\n      platform\r\n    } = clientContext;\r\n\r\n    const {info, requests} = platform;\r\n    this.defaultHeaders = defaultHeaders(sdkKey, info);\r\n    this.eventsUri = eventsUri;\r\n    this.requests = requests;\r\n  }\r\n\r\n  async send(payload: string, retry: boolean): Promise<IEventSenderResult> {\r\n    const res: IEventSenderResult = {\r\n      status: DeliveryStatus.Succeeded,\r\n    };\r\n\r\n    const headers: Record<string, string> = {\r\n      ...this.defaultHeaders,\r\n      'content-type': 'application/json',\r\n    }\r\n\r\n    let error;\r\n    try {\r\n      const {status} = await this.requests.fetch(this.eventsUri, {\r\n        headers,\r\n        body: payload,\r\n        method: 'POST',\r\n      });\r\n\r\n      if (status >= 200 && status <= 299) {\r\n        return res;\r\n      }\r\n\r\n      error = new UnexpectedResponseError(\r\n        httpErrorMessage({status, message: 'some events were dropped'}, 'event posting'),\r\n      );\r\n\r\n      if (!isHttpRecoverable(status)) {\r\n        res.status = DeliveryStatus.FailedAndMustShutDown;\r\n        res.error = error;\r\n        return res;\r\n      }\r\n    } catch (err) {\r\n      error = err;\r\n    }\r\n\r\n    // recoverable but not retrying\r\n    if (error && !retry) {\r\n      res.status = DeliveryStatus.Failed;\r\n      res.error = error;\r\n      return res;\r\n    }\r\n\r\n    // wait 1 second before retrying\r\n    await sleep();\r\n\r\n    return this.send(payload, false);\r\n  }\r\n}","import { IEventSerializer } from \"./EventSerializer\";\r\nimport { EvalEvent, IEvent, MetricEvent } from \"./event\";\r\n\r\nexport class DefaultEventSerializer implements IEventSerializer {\r\n  serialize(events: IEvent[]): string {\r\n    const payload = events\r\n      .map(event => event instanceof EvalEvent || event instanceof MetricEvent ? event.toPayload() : null)\r\n      .filter(event => event !== null);\r\n\r\n    return JSON.stringify(payload);\r\n  }\r\n}","import { ILogger } from \"../logging/ILogger\";\r\nimport ClientContext from \"../options/ClientContext\";\r\nimport { DeliveryStatus, IEventSender } from \"./IEventSender\";\r\nimport { IEventQueue } from \"./IEventQueue\";\r\nimport { DefaultEventQueue } from \"./DefaultEventQueue\";\r\nimport { DefaultEventSender } from \"./DefaultEventSender\";\r\nimport { AsyncEvent, FlushEvent, IEvent, PayloadEvent, ShutdownEvent } from \"./event\";\r\nimport { IEventSerializer } from \"./EventSerializer\";\r\nimport { DefaultEventSerializer } from \"./DefaultEventSerializer\";\r\nimport sleep from \"../utils/sleep\";\r\n\r\nexport class EventDispatcher {\r\n  private readonly logger: ILogger;\r\n  private sender: IEventSender;\r\n  private buffer: IEventQueue;\r\n  private serializer: IEventSerializer;\r\n\r\n  private maxEventPerRequest = 50;\r\n  private stopped: boolean = false;\r\n\r\n  constructor(clientContext: ClientContext, queue: IEventQueue) {\r\n    const {logger, maxEventsInQueue} = clientContext;\r\n    this.logger = logger!;\r\n\r\n    this.buffer = new DefaultEventQueue(maxEventsInQueue, this.logger);\r\n    this.sender = new DefaultEventSender(clientContext);\r\n    this.serializer = new DefaultEventSerializer();\r\n\r\n    this.dispatchLoop(queue).then();\r\n  }\r\n\r\n  private async dispatchLoop(queue: IEventQueue) {\r\n    this.logger.debug('Start dispatch loop.');\r\n\r\n    let running = true;\r\n    while (running) {\r\n      try {\r\n        const event = queue.shift();\r\n\r\n        if (event === undefined) {\r\n          await sleep(1000);\r\n          continue;\r\n        }\r\n\r\n        if (event instanceof PayloadEvent) {\r\n          this.addEventToBuffer(event);\r\n        } else if (event instanceof FlushEvent) {\r\n          await this.triggerFlush(event);\r\n        } else if (event instanceof ShutdownEvent) {\r\n          await this.triggerFlush(event);\r\n          this.stopped = true;\r\n          running = false;\r\n        }\r\n      } catch (err) {\r\n        this.logger.error('Unexpected error in event dispatcher.', err);\r\n      }\r\n    }\r\n\r\n    this.logger.debug('Finish dispatch loop.');\r\n  }\r\n\r\n  private addEventToBuffer(event: IEvent) {\r\n    if (this.stopped) {\r\n      return;\r\n    }\r\n\r\n    if (this.buffer.addEvent(event)) {\r\n      this.logger.debug('Added event to buffer.');\r\n    } else {\r\n      this.logger.warn('Exceeded event queue capacity, event will be dropped. Increase capacity to avoid dropping events.');\r\n    }\r\n  }\r\n\r\n  private async triggerFlush(event: AsyncEvent) {\r\n    if (this.stopped) {\r\n      event.complete();\r\n      return;\r\n    }\r\n\r\n    if (this.buffer.isEmpty) {\r\n      event.complete();\r\n      this.logger.debug('Flush empty buffer.');\r\n      // There are no events to flush. If we don't complete the message, then the async task may never\r\n      // complete (if it had a non-zero positive timeout, then it would complete after the timeout).\r\n      return;\r\n    }\r\n\r\n    const snapshot = this.buffer.eventsSnapshot;\r\n    this.buffer.clear();\r\n    try {\r\n      await this.flushEvents(snapshot);\r\n      this.logger.debug(`${ snapshot.length } events has been flushed.`);\r\n    } catch (err) {\r\n      this.logger.warn('Exception happened when flushing events', err);\r\n    }\r\n\r\n    event.complete();\r\n  }\r\n\r\n  private async flushEvents(events: IEvent[]) {\r\n    events = this.getUniqueEvents(events);\r\n    const total = events.length;\r\n    for (let i = 0; i < total; i += this.maxEventPerRequest) {\r\n      const length = Math.min(this.maxEventPerRequest, total - i);\r\n      const slice = events.slice(i, i + length);\r\n      const payload = this.serializer.serialize(slice);\r\n\r\n      const {status} = await this.sender.send(payload, true);\r\n      if (status === DeliveryStatus.FailedAndMustShutDown) {\r\n        this.stopped = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  private getUniqueEvents(events: IEvent[]): IEvent[] {\r\n    const uniqueEvents: IEvent[] = [];\r\n    const hashes: string[] = [];\r\n\r\n    for (const event of events) {\r\n      if (!hashes.includes(event.hash)) {\r\n        uniqueEvents.push(event);\r\n        hashes.push(event.hash);\r\n      }\r\n    }\r\n\r\n    return uniqueEvents;\r\n  }\r\n}","export enum DeliveryStatus {\r\n  Succeeded,\r\n  Failed,\r\n  FailedAndMustShutDown\r\n}\r\n\r\nexport interface IEventSenderResult {\r\n  status: DeliveryStatus,\r\n  error?: any\r\n}\r\n\r\nexport interface IEventSender {\r\n  send(payload: string, retry: boolean): Promise<IEventSenderResult>;\r\n}","import { IEventProcessor } from \"./IEventProcessor\";\r\nimport { IEvent } from \"./event\";\r\n\r\nexport class NullEventProcessor implements IEventProcessor {\r\n  flush(): Promise<void> {\r\n    return Promise.resolve();\r\n  }\r\n\r\n  close(): Promise<void> {\r\n    return Promise.resolve();\r\n  }\r\n\r\n  record(event: IEvent | null): boolean {\r\n    return false;\r\n  }\r\n}","import { IUser } from \"../options/IUser\";\r\nimport { IVariation } from \"../evaluation/data/IFlag\";\r\n\r\nexport interface IEvent {\r\n  hash: string;\r\n}\r\n\r\nexport class AsyncEvent implements IEvent {\r\n  private readonly isCompletedPromise?: Promise<AsyncEvent>;\r\n  private resolveFn?: (value: AsyncEvent) => void;\r\n  timestamp = (new Date()).getTime();\r\n\r\n  get hash(): string {\r\n    return this.timestamp.toString();\r\n  }\r\n\r\n  constructor() {\r\n    this.isCompletedPromise = new Promise<AsyncEvent>((resolve) => {\r\n      this.resolveFn = resolve;\r\n    });\r\n  }\r\n\r\n  waitForCompletion(): Promise<AsyncEvent> {\r\n    return this.isCompletedPromise!;\r\n  }\r\n\r\n  complete() {\r\n    this.resolveFn?.(this);\r\n  }\r\n}\r\n\r\nexport class FlushEvent extends AsyncEvent {\r\n}\r\n\r\nexport class ShutdownEvent extends AsyncEvent {\r\n}\r\n\r\nexport class PayloadEvent implements IEvent {\r\n  timestamp = (new Date()).getTime();\r\n\r\n  get hash(): string {\r\n    return this.timestamp.toString();\r\n  }\r\n\r\n  toPayload(): any {\r\n  };\r\n}\r\n\r\nexport class MetricEvent extends PayloadEvent {\r\n  constructor(\r\n    public user: IUser,\r\n    public eventName: string,\r\n    public appType: string,\r\n    public metricValue: number\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  private userPayload() {\r\n    return {\r\n      keyId: this.user.keyId,\r\n      name: this.user.name,\r\n      customizedProperties: this.user.customizedProperties\r\n    }\r\n  }\r\n\r\n  toPayload(): any {\r\n    return {\r\n      user: this.userPayload(),\r\n      metrics: [{\r\n        route: 'index/metric',\r\n        timestamp: this.timestamp,\r\n        numericValue: this.metricValue,\r\n        appType: this.appType,\r\n        eventName: this.eventName,\r\n        type: 'CustomEvent'\r\n      }]\r\n    }\r\n  }\r\n\r\n  get hash(): string {\r\n    const payload = this.toPayload();\r\n    const hasObject = {\r\n      user: payload.user,\r\n      metrics: payload.metrics.map((m: any) => ({...m, timestamp: undefined}))\r\n    }\r\n    return JSON.stringify(hasObject);\r\n  }\r\n}\r\n\r\nexport class EvalEvent extends PayloadEvent {\r\n  constructor(\r\n    public user: IUser,\r\n    public flagKey: string,\r\n    public variation: IVariation,\r\n    public sendToExperiment: boolean\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  private userPayload() {\r\n    return {\r\n      keyId: this.user.keyId,\r\n      name: this.user.name,\r\n      customizedProperties: this.user.customizedProperties\r\n    }\r\n  }\r\n\r\n  toPayload(): any {\r\n    return {\r\n      user: this.userPayload(),\r\n      variations: [{\r\n        featureFlagKey: this.flagKey,\r\n        sendToExperiment: this.sendToExperiment,\r\n        timestamp: this.timestamp,\r\n        variation: this.variation\r\n      }]\r\n    }\r\n  }\r\n\r\n  get hash(): string {\r\n    const payload = this.toPayload();\r\n    const hasObject = {\r\n      user: payload.user,\r\n      variations: payload.variations.map((m: any) => ({...m, timestamp: undefined}))\r\n    }\r\n\r\n    return JSON.stringify(hasObject);\r\n  }\r\n}","export * from './DefaultEventProcessor';\r\nexport * from './DefaultEventQueue';\r\nexport * from './DefaultEventSender';\r\nexport * from './DefaultEventSerializer';\r\nexport * from './event';\r\nexport * from './EventDispatcher';\r\nexport * from './EventSerializer';\r\nexport * from './IEventProcessor';\r\nexport * from './IEventQueue';\r\nexport * from './IEventSender';\r\nexport * from './NullEventProcessor';\r\n","export * from './bootstrap';\r\nexport * from './data-sources';\r\nexport * from './evaluation';\r\nexport * from './events';\r\nexport * from './logging';\r\nexport * from './options';\r\nexport * from './platform';\r\nexport * from './store';\r\nexport * from './data-sync';\r\nexport * from './utils';\r\n\r\nexport * from './Configuration';\r\nexport * from './constants';\r\nexport * from './Context';\r\nexport * from './errors';\r\nexport * from './FbClientBuilder';\r\nexport * from './IContextProperty';\r\nexport * from './IDataKind';\r\nexport * from './IFbClient';\r\nexport * from './IVersionedData';\r\n\r\n","import format from './format';\r\nimport { ILogger } from \"./ILogger\";\r\nimport { IBasicLoggerOptions } from \"./IBasicLoggerOptions\";\r\n\r\nconst LogPriority = {\r\n  debug: 0,\r\n  info: 1,\r\n  warn: 2,\r\n  error: 3,\r\n  none: 4,\r\n};\r\n\r\nconst LevelNames = ['debug', 'info', 'warn', 'error', 'none'];\r\n\r\n/**\r\n * A basic logger which handles filtering by level.\r\n *\r\n * With the default options it will write to `console.error`\r\n * and it will use the formatting provided by `console.error`.\r\n * If the destination is overwritten, then it will use an included\r\n * formatter similar to `util.format`.\r\n *\r\n * If a formatter is available, then that should be overridden\r\n * as well for performance.\r\n */\r\nexport class BasicLogger implements ILogger {\r\n  private logLevel: number;\r\n\r\n  private name: string;\r\n\r\n  private destination?: (line: string) => void;\r\n\r\n  private formatter?: (...args: any[]) => string;\r\n\r\n  /**\r\n   * This should only be used as a default fallback and not as a convenient\r\n   * solution. In most cases you should construct a new instance with the\r\n   * appropriate options for your specific needs.\r\n   */\r\n  static get() {\r\n    return new BasicLogger({});\r\n  }\r\n\r\n  constructor(options: IBasicLoggerOptions) {\r\n    this.logLevel = LogPriority[options.level ?? 'info'] ?? LogPriority.info;\r\n    this.name = options.name ?? 'FeatBit';\r\n    // eslint-disable-next-line no-console\r\n    this.destination = options.destination;\r\n    this.formatter = options.formatter;\r\n  }\r\n\r\n  private tryFormat(...args: any[]): string {\r\n    try {\r\n      if (this.formatter) {\r\n        // In case the provided formatter fails.\r\n        return this.formatter?.(...args);\r\n      }\r\n      return format(...args);\r\n    } catch {\r\n      return format(...args);\r\n    }\r\n  }\r\n\r\n  private tryWrite(msg: string) {\r\n    try {\r\n      this.destination!(msg);\r\n    } catch {\r\n      // eslint-disable-next-line no-console\r\n      console.error(msg);\r\n    }\r\n  }\r\n\r\n  private log(level: number, args: any[]) {\r\n    if (level >= this.logLevel) {\r\n      const prefix = `${ LevelNames[level] }: [${ this.name }]`;\r\n      try {\r\n        if (this.destination) {\r\n          this.tryWrite(`${ prefix } ${ this.tryFormat(...args) }`);\r\n        } else {\r\n          // `console.error` has its own formatter.\r\n          // So we don't need to do anything.\r\n          // eslint-disable-next-line no-console\r\n          console.error(...args);\r\n        }\r\n      } catch {\r\n        // If all else fails do not break.\r\n        // eslint-disable-next-line no-console\r\n        console.error(...args);\r\n      }\r\n    }\r\n  }\r\n\r\n  error(...args: any[]): void {\r\n    this.log(LogPriority.error, args);\r\n  }\r\n\r\n  warn(...args: any[]): void {\r\n    this.log(LogPriority.warn, args);\r\n  }\r\n\r\n  info(...args: any[]): void {\r\n    this.log(LogPriority.info, args);\r\n  }\r\n\r\n  debug(...args: any[]): void {\r\n    this.log(LogPriority.debug, args);\r\n  }\r\n}\r\n","import { ILogger } from \"./ILogger\";\r\nimport { TypeValidators } from \"../options/Validators\";\r\n\r\nconst loggerRequirements = {\r\n  error: TypeValidators.Function,\r\n  warn: TypeValidators.Function,\r\n  info: TypeValidators.Function,\r\n  debug: TypeValidators.Function,\r\n};\r\n\r\n/**\r\n * The safeLogger logic exists because we allow the application to pass in a custom logger, but\r\n * there is no guarantee that the logger works correctly and if it ever throws exceptions there\r\n * could be serious consequences (e.g. an uncaught exception within an error event handler, due\r\n * to the SDK trying to log the error, can terminate the application). An exception could result\r\n * from faulty logic in the logger implementation, or it could be that this is not a logger at\r\n * all but some other kind of object; the former is handled by a catch block that logs an error\r\n * message to the SDK's default logger, and we can at least partly guard against the latter by\r\n * checking for the presence of required methods at configuration time.\r\n */\r\nexport default class SafeLogger implements ILogger {\r\n  private logger: ILogger;\r\n\r\n  private fallback: ILogger;\r\n\r\n  /**\r\n   * Construct a safe logger with the specified logger.\r\n   * @param logger The logger to use.\r\n   * @param fallback A fallback logger to use in case an issue is  encountered using\r\n   * the provided logger.\r\n   */\r\n  constructor(logger: ILogger, fallback: ILogger) {\r\n    Object.entries(loggerRequirements).forEach(([level, validator]) => {\r\n      if (!validator.is((logger as any)[level])) {\r\n        throw new Error(`Provided logger instance must support logger.${ level }(...) method`);\r\n        // Note that the SDK normally does not throw exceptions to the application, but that rule\r\n        // does not apply to FbClientNode.init() which will throw an exception if the parameters are so\r\n        // invalid that we cannot proceed with creating the client. An invalid logger meets those\r\n        // criteria since the SDK calls the logger during nearly all of its operations.\r\n      }\r\n    });\r\n    this.logger = logger;\r\n    this.fallback = fallback;\r\n  }\r\n\r\n  private log(level: 'error' | 'warn' | 'info' | 'debug', args: any[]) {\r\n    try {\r\n      this.logger[level](...args);\r\n    } catch {\r\n      // If all else fails do not break.\r\n      this.fallback[level](...args);\r\n    }\r\n  }\r\n\r\n  error(...args: any[]): void {\r\n    this.log('error', args);\r\n  }\r\n\r\n  warn(...args: any[]): void {\r\n    this.log('warn', args);\r\n  }\r\n\r\n  info(...args: any[]): void {\r\n    this.log('info', args);\r\n  }\r\n\r\n  debug(...args: any[]): void {\r\n    this.log('debug', args);\r\n  }\r\n}","import { TypeValidators } from \"../options/Validators\";\r\n\r\n\r\n/**\r\n * Attempt to produce a string representation of a value.\r\n * The format should be roughly comparable to `util.format`\r\n * aside from object which will be JSON versus the `util.inspect`\r\n * format.\r\n * @param val\r\n * @returns A string representation of the value if possible.\r\n */\r\nfunction tryStringify(val: any) {\r\n  if (typeof val === 'string') {\r\n    return val;\r\n  }\r\n  if (val === undefined) {\r\n    return 'undefined';\r\n  }\r\n  if (val === null) {\r\n    return 'null';\r\n  }\r\n  if (Object.prototype.hasOwnProperty.call(val, 'toString')) {\r\n    try {\r\n      return val.toString();\r\n    } catch {\r\n      /* Keep going */\r\n    }\r\n  }\r\n\r\n  if (typeof val === 'bigint') {\r\n    return `${ val }n`;\r\n  }\r\n  try {\r\n    return JSON.stringify(val);\r\n  } catch (error) {\r\n    if (error instanceof TypeError && error.message.indexOf('circular') >= 0) {\r\n      return '[Circular]';\r\n    }\r\n    return '[Not Stringifiable]';\r\n  }\r\n}\r\n\r\n/**\r\n * Attempt to produce a numeric representation.\r\n * BigInts have an `n` suffix.\r\n * @param val\r\n * @returns The numeric representation or 'NaN' if not numeric.\r\n */\r\nfunction toNumber(val: any): string {\r\n  // Symbol has to be treated special because it will\r\n  // throw an exception if an attempt is made to convert it.\r\n  if (typeof val === 'symbol') {\r\n    return 'NaN';\r\n  }\r\n  if (typeof val === 'bigint') {\r\n    return `${ val }n`;\r\n  }\r\n  return String(Number(val));\r\n}\r\n\r\n/**\r\n * Attempt to produce an integer representation.\r\n * BigInts have an `n` suffix.\r\n * @param val\r\n * @returns The integer representation or 'NaN' if not numeric.\r\n */\r\nfunction toInt(val: any): string {\r\n  if (typeof val === 'symbol') {\r\n    return 'NaN';\r\n  }\r\n  if (typeof val === 'bigint') {\r\n    return `${ val }n`;\r\n  }\r\n  return String(parseInt(val, 10));\r\n}\r\n\r\n/**\r\n * Attempt to produce a float representation.\r\n * BigInts have an `n` suffix.\r\n * @param val\r\n * @returns The integer representation or 'NaN' if not numeric.\r\n */\r\nfunction toFloat(val: any): string {\r\n  if (typeof val === 'symbol') {\r\n    return 'NaN';\r\n  }\r\n  return String(parseFloat(val));\r\n}\r\n\r\n// Based on:\r\n// https://nodejs.org/api/util.html#utilformatformat-args\r\n// The result will not match node exactly, but it should get the\r\n// right information through.\r\nconst escapes: Record<string, (val: any) => string> = {\r\n  s: (val: any) => tryStringify(val),\r\n  d: (val: any) => toNumber(val),\r\n  i: (val: any) => toInt(val),\r\n  f: (val: any) => toFloat(val),\r\n  j: (val: any) => tryStringify(val),\r\n  o: (val: any) => tryStringify(val),\r\n  O: (val: any) => tryStringify(val),\r\n  c: () => '',\r\n};\r\n\r\n/**\r\n * A basic formatted for use where `util.format` is not available.\r\n * This will not be as performant, but it will produce formatted\r\n * messages.\r\n *\r\n * @internal\r\n *\r\n * @param args\r\n * @returns Formatted string.\r\n */\r\nexport default function format(...args: any[]): string {\r\n  const formatString = args.shift();\r\n  if (TypeValidators.String.is(formatString)) {\r\n    let out = '';\r\n    let i = 0;\r\n    while (i < formatString.length) {\r\n      const char = formatString.charAt(i);\r\n      if (char === '%') {\r\n        const nextIndex = i + 1;\r\n        if (nextIndex < formatString.length) {\r\n          const nextChar = formatString.charAt(i + 1);\r\n          if (nextChar in escapes && args.length) {\r\n            const value = args.shift();\r\n            // This rule is for math.\r\n            // eslint-disable-next-line no-unsafe-optional-chaining\r\n            out += escapes[nextChar]?.(value);\r\n          } else if (nextChar === '%') {\r\n            out += '%';\r\n          } else {\r\n            out += `%${ nextChar }`;\r\n          }\r\n          i += 2;\r\n        }\r\n      } else {\r\n        out += char;\r\n        i += 1;\r\n      }\r\n    }\r\n    // If there are any args left after we exhaust the format string\r\n    // then just stick those on the end.\r\n    if (args.length) {\r\n      if (out.length) {\r\n        out += ' ';\r\n      }\r\n      out += args.map(tryStringify).join(' ');\r\n    }\r\n    return out;\r\n  }\r\n  return args.map(tryStringify).join(' ');\r\n}\r\n","export * from './BasicLogger';\r\nexport * from './format';\r\nexport * from './IBasicLoggerOptions';\r\nexport * from './ILogger';\r\nexport * from './LogLevel';\r\nexport * from './SafeLogger';","import { ILogger } from \"../logging/ILogger\";\r\nimport { IPlatform } from \"../platform/IPlatform\";\r\nimport { IClientContext } from \"./IClientContext\";\r\nimport { IUser } from \"./IUser\";\r\n\r\n/**\r\n * The client context provides basic configuration and platform support which are required\r\n * when building SDK components.\r\n */\r\nexport default class ClientContext implements IClientContext {\r\n  flushInterval: number;\r\n  maxEventsInQueue: number;\r\n  offline: boolean;\r\n  logger: ILogger;\r\n  eventsUri: string;\r\n  pollingUri: string;\r\n  streamingUri: string;\r\n\r\n  constructor(\r\n    public readonly sdkKey: string,\r\n    configuration: {\r\n      logger?: ILogger;\r\n      offline?: boolean;\r\n      flushInterval: number;\r\n      maxEventsInQueue: number;\r\n      streamingUri: string;\r\n      pollingUri: string;\r\n      eventsUri: string;\r\n    },\r\n    public readonly platform: IPlatform,\r\n  ) {\r\n    this.logger = configuration.logger!;\r\n    this.offline = configuration.offline!;\r\n    this.flushInterval = configuration.flushInterval;\r\n    this.maxEventsInQueue = configuration.maxEventsInQueue;\r\n    this.streamingUri = configuration.streamingUri;\r\n    this.pollingUri = configuration.pollingUri;\r\n    this.eventsUri = configuration.eventsUri;\r\n  }\r\n}","/**\r\n * Messages for issues which can be encountered from processing the configuration options.\r\n */\r\nexport default class OptionMessages {\r\n  static optionBelowMinimum(name: string, value: number, min: number): string {\r\n    return `Config option \"${ name }\" had invalid value of ${ value }, using minimum of ${ min } instead`;\r\n  }\r\n\r\n  static unknownOption(name: string): string {\r\n    return `Ignoring unknown config option \"${ name }\"`;\r\n  }\r\n\r\n  static wrongOptionType(name: string, expectedType: string, actualType: string): string {\r\n    return `Config option \"${ name }\" should be of type ${ expectedType }, got ${ actualType }, using default value`;\r\n  }\r\n\r\n  static wrongOptionTypeBoolean(name: string, actualType: string): string {\r\n    return `Config option \"${ name }\" should be a boolean, got ${ actualType }, converting to boolean`;\r\n  }\r\n\r\n  static partialEndpoint(name: string): string {\r\n    return `You have set custom uris without specifying the ${ name } URI; connections may not work properly`;\r\n  }\r\n\r\n  static mandatory(name: string): string {\r\n    return `${ name } is mandatory`;\r\n  }\r\n\r\n  static invalidOptionValue(name: string): string {\r\n    return `Invalid option value: ${ name }`;\r\n  }\r\n\r\n  static missingKeyInBootstrapValue(key: string): string {\r\n    return `Missing key \"${ key }\" in bootstrap value`;\r\n  }\r\n}","import { IUser } from \"./IUser\";\r\nimport {IContextProperty} from \"../IContextProperty\";\r\n\r\n/**\r\n * Creates an instance of the FeatBit user.\r\n *\r\n * @return\r\n *   The new {@link IUser} instance.\r\n */\r\nexport class UserBuilder {\r\n  private _keyId: string = '';\r\n  private _name: string = '';\r\n  private _custom: IContextProperty[] = [];\r\n\r\n  constructor(keyId: string) {\r\n    this._keyId = keyId;\r\n  }\r\n\r\n  name(name: string): UserBuilder {\r\n    this._name = name;\r\n    return this;\r\n  }\r\n\r\n  custom(propertyName: string, value: string): UserBuilder {\r\n    this._custom?.push({ name: propertyName, value: value });\r\n    return this;\r\n  }\r\n\r\n  build(): IUser {\r\n    return {\r\n      name: this._name,\r\n      keyId: this._keyId,\r\n      customizedProperties: this._custom\r\n    };\r\n  }\r\n}","/* eslint-disable class-methods-use-this */\r\n/* eslint-disable max-classes-per-file */\r\n\r\n// The classes here are static, but needs to be instantiated to\r\n// support the generic functionality. Which is why we do not care about using\r\n// `this`\r\n\r\n// These validators are also of trivial complexity, so we are allowing more than\r\n// one per file.\r\n\r\nimport OptionMessages from \"./OptionMessages\";\r\nimport { IFlagBase } from \"../evaluation\";\r\n\r\n/**\r\n * Interface for type validation.\r\n */\r\nexport interface TypeValidator {\r\n  // holding validation error messages\r\n  messages?: string[];\r\n\r\n  is(u: unknown): boolean;\r\n\r\n  getType(): string;\r\n}\r\n\r\n/**\r\n * Validate a factory or instance.\r\n */\r\nexport class FactoryOrInstance implements TypeValidator {\r\n  is(factoryOrInstance: unknown) {\r\n    if (Array.isArray(factoryOrInstance)) {\r\n      return false;\r\n    }\r\n    const anyFactory = factoryOrInstance as any;\r\n    const typeOfFactory = typeof anyFactory;\r\n    return typeOfFactory === 'function' || typeOfFactory === 'object';\r\n  }\r\n\r\n  getType(): string {\r\n    return 'factory method or object';\r\n  }\r\n}\r\n\r\n/**\r\n * Validate a basic type.\r\n */\r\nexport class Type<T> implements TypeValidator {\r\n  private typeName: string;\r\n\r\n  protected typeOf: string;\r\n\r\n  constructor(typeName: string, example: T) {\r\n    this.typeName = typeName;\r\n    this.typeOf = typeof example;\r\n  }\r\n\r\n  is(u: unknown): u is T {\r\n    if (Array.isArray(u)) {\r\n      return false;\r\n    }\r\n    return typeof u === this.typeOf;\r\n  }\r\n\r\n  getType(): string {\r\n    return this.typeName;\r\n  }\r\n}\r\n\r\n/**\r\n * Validate an array of the specified type.\r\n *\r\n * This does not validate instances of types. All class instances\r\n * of classes will simply objects.\r\n */\r\nexport class TypeArray<T> implements TypeValidator {\r\n  private typeName: string;\r\n\r\n  protected typeOf: string;\r\n\r\n  constructor(typeName: string, example: T) {\r\n    this.typeName = typeName;\r\n    this.typeOf = typeof example;\r\n  }\r\n\r\n  is(u: unknown): u is T {\r\n    if (Array.isArray(u)) {\r\n      if (u.length > 0) {\r\n        return u.every((val) => typeof val === this.typeOf);\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  getType(): string {\r\n    return this.typeName;\r\n  }\r\n}\r\n\r\n/**\r\n * Validate a value is a number and is greater or eval than a minimum.\r\n */\r\nexport class NumberWithMinimum extends Type<number> {\r\n  readonly min: number;\r\n\r\n  constructor(min: number) {\r\n    super(`number with minimum value of ${ min }`, 0);\r\n    this.min = min;\r\n  }\r\n\r\n  override is(u: unknown): u is number {\r\n    return typeof u === this.typeOf && (u as number) >= this.min;\r\n  }\r\n}\r\n\r\n/**\r\n * Validate a value is a string and it matches the given expression.\r\n */\r\nexport class StringMatchingRegex extends Type<string> {\r\n  readonly expression: RegExp;\r\n\r\n  constructor(expression: RegExp) {\r\n    super(`string matching ${ expression }`, '');\r\n    this.expression = expression;\r\n  }\r\n\r\n  override is(u: unknown): u is string {\r\n    return !!(u as string).match(this.expression);\r\n  }\r\n}\r\n\r\n/**\r\n * Validate a value is a function.\r\n */\r\nexport class Function implements TypeValidator {\r\n  is(u: unknown): u is (...args: any[]) => void {\r\n    // We cannot inspect the parameters and there isn't really\r\n    // a generic function type we can instantiate.\r\n    // So the type guard is here just to make TS comfortable\r\n    // calling something after using this guard.\r\n    return typeof u === 'function';\r\n  }\r\n\r\n  getType(): string {\r\n    return 'function';\r\n  }\r\n}\r\n\r\nexport class NullableBoolean implements TypeValidator {\r\n  is(u: unknown): boolean {\r\n    return typeof u === 'boolean' || typeof u === 'undefined' || u === null;\r\n  }\r\n\r\n  getType(): string {\r\n    return 'boolean | undefined | null';\r\n  }\r\n}\r\n\r\nexport class BootstrapValidator implements TypeValidator {\r\n  messages: string[] = [];\r\n\r\n  is(u: unknown): boolean {\r\n    if (typeof u !== 'object' || u === null) {\r\n      this.messages.push(OptionMessages.invalidOptionValue('bootstrap'));\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const bootstrap = u as IFlagBase[];\r\n      for (let flag of bootstrap) {\r\n        const hasMandatoryKeys = ['id', 'variation'].every((key) => Object.keys(flag).includes(key));\r\n        const keys = Object.keys(flag);\r\n\r\n        if (keys.includes('id')) {\r\n          this.messages.push(OptionMessages.missingKeyInBootstrapValue('id'));\r\n        }\r\n\r\n        if (keys.includes('variation')) {\r\n          this.messages.push(OptionMessages.missingKeyInBootstrapValue('variation'));\r\n        }\r\n\r\n        if (this.messages.length > 0) {\r\n          return false;\r\n        }\r\n      }\r\n    } catch (_) {\r\n      this.messages.push(OptionMessages.wrongOptionType('bootstrap', this.getType(), typeof u));\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  getType(): string {\r\n    return 'IFlagBase[]';\r\n  }\r\n}\r\n\r\nexport class UserValidator implements TypeValidator {\r\n  messages: string[] = [];\r\n\r\n  is(u: unknown): boolean {\r\n    if (typeof u !== 'object' || u === null) {\r\n      this.messages.push(OptionMessages.mandatory('user'));\r\n      return false;\r\n    }\r\n\r\n    const user = u as any;\r\n\r\n    if (typeof user.keyId !== 'string' || user.keyId.trim() === '') {\r\n      this.messages.push(OptionMessages.mandatory('user.keyId'));\r\n      return false;\r\n    }\r\n\r\n    if (typeof user.name !== 'string' || user.name.trim() === '') {\r\n      this.messages.push(OptionMessages.mandatory('user.name'));\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  getType(): string {\r\n    return 'user';\r\n  }\r\n}\r\n\r\n// Our reference SDK, Go, parses date/time strings with the time.RFC3339Nano format.\r\n// This regex should match strings that are valid in that format, and no others.\r\n// Acceptable:\r\n//   2019-10-31T23:59:59Z, 2019-10-31T23:59:59.100Z,\r\n//   2019-10-31T23:59:59-07, 2019-10-31T23:59:59-07:00, etc.\r\n// Unacceptable: no \"T\", no time zone designation\r\nconst DATE_REGEX = /^\\d\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(\\.\\d\\d*)?(Z|[-+]\\d\\d(:\\d\\d)?)/;\r\n\r\n/**\r\n * Validate a value is a date. Values which are numbers are treated as dates and any string\r\n * which if compliant with `time.RFC3339Nano` is a date.\r\n */\r\nexport class DateValidator implements TypeValidator {\r\n  is(u: unknown): boolean {\r\n    return typeof u === 'number' || (typeof u === 'string' && DATE_REGEX.test(u));\r\n  }\r\n\r\n  getType(): string {\r\n    return 'date';\r\n  }\r\n}\r\n\r\n/**\r\n * Validates that a string is a valid kind.\r\n */\r\nexport class KindValidator extends StringMatchingRegex {\r\n  constructor() {\r\n    super(/^(\\w|\\.|-)+$/);\r\n  }\r\n\r\n  override is(u: unknown): u is string {\r\n    return super.is(u) && u !== 'kind';\r\n  }\r\n}\r\n\r\n/**\r\n * A set of standard type validators.\r\n */\r\nexport class TypeValidators {\r\n  static readonly String = new Type<string>('string', '');\r\n\r\n  static readonly Number = new Type<number>('number', 0);\r\n\r\n  static readonly ObjectOrFactory = new FactoryOrInstance();\r\n\r\n  static readonly Object = new Type<object>('object', {});\r\n\r\n  static readonly StringArray = new TypeArray<string>('string[]', '');\r\n\r\n  static readonly Boolean = new Type<boolean>('boolean', true);\r\n\r\n  static readonly User = new Type<object>('object', {});\r\n\r\n  static readonly Bootstrap = new Type<object>('object', {});\r\n\r\n  static readonly Function = new Function();\r\n\r\n  static createTypeArray<T>(typeName: string, example: T) {\r\n    return new TypeArray<T>(typeName, example);\r\n  }\r\n\r\n  static numberWithMin(min: number): NumberWithMinimum {\r\n    return new NumberWithMinimum(min);\r\n  }\r\n\r\n  static stringMatchingRegex(expression: RegExp): StringMatchingRegex {\r\n    return new StringMatchingRegex(expression);\r\n  }\r\n\r\n  static readonly Date = new DateValidator();\r\n\r\n  static readonly Kind = new KindValidator();\r\n  static readonly NullableBoolean = new NullableBoolean();\r\n}","export * from './ClientContext';\r\nexport * from './IClientContext';\r\nexport * from './IOptions';\r\nexport * from './IUser';\r\nexport * from './IValidatedOptions';\r\nexport * from './OptionMessages';\r\nexport * from './UserBuilder';\r\nexport * from './Validators';","import { IInfo, IPlatformData, ISdkData } from \"../IInfo\";\r\nimport { name, version } from '../../version';\r\n\r\n\r\nexport default class BrowserInfo implements IInfo {\r\n  get appType(): string {\r\n    return 'Browser-Client-SDK';\r\n  }\r\n\r\n  platformData(): IPlatformData {\r\n    return {\r\n      os: {},\r\n      name: 'Browser',\r\n      additional: {},\r\n    };\r\n  }\r\n\r\n  sdkData(): ISdkData {\r\n    return {\r\n      name: name,\r\n      version: version,\r\n      userAgentBase: this.appType\r\n    };\r\n  }\r\n}","import { IPlatform } from \"../IPlatform\";\r\nimport { IInfo } from \"../IInfo\";\r\nimport { IRequests } from \"../requests\";\r\nimport { IOptions } from \"../../options/IOptions\";\r\nimport BrowserInfo from \"./BrowserInfo\";\r\nimport BrowserRequests from \"./BrowserRequests\";\r\nimport { IWebSocketWithEvents } from \"../IWebSocket\";\r\nimport BrowserWebSocket from \"./BrowserWebSocket\";\r\n\r\nexport default class BrowserPlatform implements IPlatform {\r\n  info: IInfo = new BrowserInfo();\r\n\r\n  requests: IRequests;\r\n  webSocket: IWebSocketWithEvents;\r\n\r\n  constructor(options: IOptions) {\r\n    this.requests = new BrowserRequests();\r\n    this.webSocket = new BrowserWebSocket();\r\n  }\r\n}","import { IRequestOptions, IRequests } from \"../requests\";\r\n\r\nexport default class BrowserRequests implements IRequests {\r\n  fetch(url: string, options: IRequestOptions = {}): Promise<any> {\r\n    return fetch(url, options);\r\n  }\r\n}","import { IWebSocket, IWebSocketConfig } from \"../IWebSocket\";\r\nimport { Emits } from \"../../utils/Emits\";\r\nimport { IEventEmitter } from \"../../utils/IEventEmitter\";\r\nimport { EventEmitter } from \"../../utils/EventEmitter\";\r\nimport { generateConnectionToken } from \"../../data-sync/utils\";\r\nimport { StreamResponseEventType } from \"../../data-sync/types\";\r\nimport { IUser } from \"../../options/IUser\";\r\n\r\nconst socketConnectionIntervals = [1000, 3000, 5000, 7000, 11000, 13000, 30000, 60000];\r\n\r\nclass BrowserWebSocket implements IWebSocket {\r\n  emitter: IEventEmitter;\r\n  private ws?: WebSocket;\r\n  private retryCounter = 0;\r\n  private closed: boolean = false;\r\n\r\n  private _config: IWebSocketConfig = {} as IWebSocketConfig;\r\n\r\n  constructor() {\r\n    this.emitter = new EventEmitter();\r\n  }\r\n\r\n  identify(user: IUser) {\r\n    this._config.user = user;\r\n    this.doDataSync();\r\n  }\r\n\r\n  connect() {\r\n    let that = this;\r\n    const startTime = Date.now();\r\n    const url = this._config.streamingUri.replace(/^http/, 'ws') + `?type=client&token=${ generateConnectionToken(this._config.sdkKey) }`;\r\n    this.ws = new WebSocket(url);\r\n\r\n    // Connection opened\r\n    that.ws?.addEventListener('open', function (this: WebSocket, event) {\r\n      // this is the websocket instance to which the current listener is binded to, it's different from that.socket\r\n      that._config.logger.info(`WebSocket connection succeeded, connection time: ${ Date.now() - startTime } ms`);\r\n      that.doDataSync();\r\n      that.sendPingMessage();\r\n    });\r\n\r\n    // Connection closed\r\n    that.ws?.addEventListener('close', function (event) {\r\n      that._config.logger.warn('WebSocket closed');\r\n      if (event.code === 4003) { // do not reconnect when 4003\r\n        return;\r\n      }\r\n\r\n      that.reconnect();\r\n    });\r\n\r\n    // Connection error\r\n    that.ws?.addEventListener('error', function (event) {\r\n      // reconnect\r\n      that._config.logger.debug('error');\r\n    });\r\n\r\n    // Listen for messages\r\n    that.ws?.addEventListener('message', function (event) {\r\n      const message = JSON.parse(event.data as string);\r\n      if (message.messageType === 'data-sync') {\r\n        switch (message.data.eventType) {\r\n          case StreamResponseEventType.patch:\r\n            that.emitter.emit('patch', message);\r\n            break;\r\n          case StreamResponseEventType.full:\r\n            that.emitter.emit('put', message);\r\n            break;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  close() {\r\n    this.closed = true;\r\n    this.ws?.close(4003, 'The client is closed by user');\r\n    this.ws = undefined;\r\n  }\r\n\r\n  config(param: IWebSocketConfig) {\r\n    if (param.emitter) {\r\n      this.emitter = param.emitter;\r\n    }\r\n\r\n    this._config = {...param};\r\n  }\r\n\r\n  private sendPingMessage() {\r\n    const payload = {\r\n      messageType: 'ping',\r\n      data: null\r\n    };\r\n\r\n    setTimeout(() => {\r\n      try {\r\n        if (this.ws?.readyState === WebSocket.OPEN) {\r\n          this._config.logger.debug('sending ping')\r\n          this.ws.send(JSON.stringify(payload));\r\n          this.sendPingMessage();\r\n        } else {\r\n          this._config.logger.debug(`socket closed at ${ new Date() }`);\r\n        }\r\n      } catch (err) {\r\n        this._config.logger.debug(err);\r\n      }\r\n    }, this._config.pingInterval);\r\n  }\r\n\r\n  private doDataSync() {\r\n    const payload = {\r\n      messageType: 'data-sync',\r\n      data: {\r\n        timestamp: this._config.getStoreTimestamp(),\r\n        user: this._config.user\r\n      }\r\n    };\r\n\r\n    try {\r\n      if (this.ws?.readyState === WebSocket.OPEN) {\r\n        this._config.logger.debug('requesting data');\r\n        this.ws?.send(JSON.stringify(payload));\r\n      } else {\r\n        this._config.logger.error(`not requesting data because socket not open`);\r\n      }\r\n    } catch (err) {\r\n      this._config.logger.debug(err);\r\n    }\r\n  }\r\n\r\n  private reconnect() {\r\n    if (!this.closed) {\r\n      this.ws = undefined;\r\n      const waitTime = socketConnectionIntervals[Math.min(this.retryCounter++, socketConnectionIntervals.length - 1)];\r\n      this._config.logger.info(`The client will try to reconnect in ${ waitTime } milliseconds.`);\r\n      setTimeout(() => {\r\n        this._config.logger.info(`The client is trying to reconnect, flag evaluation results may be stale until reconnected, waited for: ${ waitTime } milliseconds`);\r\n        this.connect();\r\n      }, waitTime);\r\n    }\r\n  }\r\n}\r\n\r\nexport default Emits(BrowserWebSocket);","import { FbClientCore } from \"../../FbClientCore\";\r\nimport { IOptions } from \"../../options/IOptions\";\r\nimport { BasicLogger } from \"../../logging/BasicLogger\";\r\nimport { EventEmitter } from \"../../utils/EventEmitter\";\r\nimport SafeLogger from \"../../logging/SafeLogger\";\r\nimport { Emits } from \"../../utils/Emits\";\r\nimport { IEventEmitter } from \"../../utils/IEventEmitter\";\r\nimport BrowserPlatform from \"./BrowserPlatform\";\r\n\r\n/**\r\n * @ignore\r\n */\r\nclass FbClient extends FbClientCore {\r\n  emitter: IEventEmitter;\r\n\r\n  constructor(options: IOptions) {\r\n    const fallbackLogger = new BasicLogger({\r\n      level: 'none',\r\n      destination: console.log\r\n    });\r\n\r\n    const logger = options.logger ? new SafeLogger(options.logger, fallbackLogger) : fallbackLogger;\r\n\r\n    const emitter = new EventEmitter(logger);\r\n\r\n    super(\r\n      {...options, logger},\r\n      new BrowserPlatform({...options, logger}),\r\n      {\r\n        onError: (err: Error) => {\r\n          if (emitter.listenerCount('error')) {\r\n            emitter.emit('error', err);\r\n          }\r\n        },\r\n        onFailed: (err: Error) => {\r\n          emitter.emit('failed', err);\r\n        },\r\n        onReady: () => {\r\n          emitter.emit('ready');\r\n        },\r\n        onUpdate: (keys: string[]) => {\r\n          emitter.emit('update', [keys]);\r\n          keys.forEach((key) => emitter.emit(`update:${ key }`, key));\r\n        },\r\n        hasEventListeners: () =>\r\n          emitter\r\n            .eventNames()\r\n            .some(\r\n              (name) =>\r\n                name === 'update' || (typeof name === 'string' && name.startsWith('update:')),\r\n            ),\r\n      },\r\n    );\r\n\r\n    this.emitter = emitter;\r\n  }\r\n}\r\n\r\nexport default Emits(FbClient);","import { IDataKind } from \"../../IDataKind\";\r\nimport {\r\n  StoreStorageKey,\r\n  IKeyedStoreItem,\r\n  IStoreDataStorage,\r\n  IStoreItem,\r\n  IStoreKindData,\r\n  CurrentUserStorageKey\r\n} from \"../../store/store\";\r\nimport { IStore } from \"../../platform/IStore\";\r\nimport { IUser } from \"../../options/IUser\";\r\nimport { ILogger } from \"../../logging/ILogger\";\r\nimport { IOptions } from \"../../options/IOptions\";\r\nimport { serializeUser } from \"../../utils/serializeUser\";\r\n\r\nexport default class LocalStorageStore implements IStore {\r\n  private store: IStoreDataStorage  = {} as IStoreDataStorage;\r\n\r\n  private initCalled = false;\r\n\r\n  private _user: IUser = {} as IUser;\r\n\r\n  private logger: ILogger;\r\n\r\n  constructor(options: IOptions) {\r\n    this.logger = options.logger!;\r\n  }\r\n\r\n  identify(user: IUser) {\r\n    this._user = {...user};\r\n\r\n    localStorage.setItem(CurrentUserStorageKey, serializeUser(this._user));\r\n    this.loadStoreFromStorage();\r\n  }\r\n\r\n  get user(): IUser {\r\n    return this._user;\r\n  }\r\n\r\n  private addItem(kind: IDataKind, key: string, item: IStoreItem) {\r\n    let items = this.store[kind.namespace];\r\n    if (!items) {\r\n      items = {};\r\n      this.store[kind.namespace] = items;\r\n    }\r\n    if (Object.hasOwnProperty.call(items, key)) {\r\n      const old = items[key];\r\n      if (!old || old.version < item.version) {\r\n        items[key] = item;\r\n      }\r\n    } else {\r\n      items[key] = item;\r\n    }\r\n\r\n    if (item.version > this.store.version) {\r\n      this.store.version = item.version;\r\n    }\r\n\r\n    this.dumpStoreToStorage();\r\n  }\r\n\r\n  get(kind: IDataKind, key: string): IStoreItem | null {\r\n    const items = this.store[kind.namespace];\r\n    if (items) {\r\n      if (Object.prototype.hasOwnProperty.call(items, key)) {\r\n        const item = items[key];\r\n        if (item) {\r\n          return item;\r\n        }\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  all(kind: IDataKind): [IStoreKindData, number] {\r\n    const result: IStoreKindData = {};\r\n    const items = this.store[kind.namespace] ?? {};\r\n    Object.entries(items).forEach(([key, item]) => {\r\n      if (item) {\r\n        result[key] = <IStoreItem>item;\r\n      }\r\n    });\r\n\r\n    return [result, this.store.version];\r\n  }\r\n\r\n  init(allData: IStoreDataStorage, callback: () => void): void {\r\n    this.store = allData as IStoreDataStorage;\r\n\r\n    Object.keys(allData).map(namespace => {\r\n      Object.entries(allData[namespace]).forEach(([_, item]) => {\r\n        const ele = item as IStoreItem;\r\n        if (ele.version > this.store.version) {\r\n          this.store.version = ele.version;\r\n        }\r\n      })\r\n    });\r\n\r\n    this.dumpStoreToStorage();\r\n    this.initCalled = true;\r\n    callback?.();\r\n  }\r\n\r\n  upsert(kind: IDataKind, data: IKeyedStoreItem, callback: () => void): void {\r\n    this.addItem(kind, data.key, data);\r\n    callback?.();\r\n  }\r\n\r\n  initialized(): boolean {\r\n    return this.initCalled;\r\n  }\r\n\r\n  /* eslint-disable class-methods-use-this */\r\n  close(): void {\r\n    // For the memory store this is a no-op.\r\n  }\r\n\r\n  getDescription(): string {\r\n    return 'local-storage-store'\r\n  }\r\n\r\n  get version(): number {\r\n    return this.store.version;\r\n  }\r\n\r\n  private dumpStoreToStorage(): void {\r\n    const storageKey = `${StoreStorageKey}-${this._user.keyId}`;\r\n    localStorage.setItem(storageKey, JSON.stringify(this.store));\r\n  }\r\n\r\n  private loadStoreFromStorage(): void {\r\n    const storageKey = `${StoreStorageKey}-${this._user.keyId}`;\r\n    const dataStoreStr = localStorage.getItem(storageKey);\r\n    let store: IStoreDataStorage | null = null;\r\n\r\n    try {\r\n      if (dataStoreStr && dataStoreStr.trim().length > 0) {\r\n        store = JSON.parse(dataStoreStr);\r\n      }\r\n    } catch (err) {\r\n      this.logger.error(`error while loading local data store: ${storageKey}`, err);\r\n    }\r\n\r\n    if (!!store) {\r\n      this.store = store;\r\n    } else {\r\n      this.store = {\r\n        flags: {},\r\n        version: 0\r\n      };\r\n    }\r\n  }\r\n}","export * from './IInfo';\r\nexport * from './IPlatform';\r\nexport * from './IWebSocket';\r\nexport * from './requests';","import { IDataKind } from \"../IDataKind\";\r\n\r\nexport default class DataKinds {\r\n  static readonly Flags: IDataKind = {\r\n    namespace: 'flags'\r\n  };\r\n}","import { IDataKind } from \"../IDataKind\";\r\nimport { StoreStorageKey, IKeyedStoreItem, IStoreDataStorage, IStoreItem, IStoreKindData } from \"./store\";\r\nimport { IStore } from \"../platform/IStore\";\r\nimport { IUser } from \"../options/IUser\";\r\nimport { IOptions } from \"../options/IOptions\";\r\n\r\nexport default class InMemoryStore implements IStore {\r\n\r\n  private allStores: { [DataStoreStorageKey: string]: IStoreDataStorage } = {};\r\n\r\n  private store: IStoreDataStorage  = {} as IStoreDataStorage;\r\n\r\n  private initCalled = false;\r\n\r\n  private _user: IUser = {} as IUser;\r\n\r\n  constructor(options: IOptions) {}\r\n\r\n  identify(user: IUser) {\r\n    this._user = {...user};\r\n\r\n    this.store = this.allStores[`${StoreStorageKey}-${this._user.keyId}`] ?? { flags: {}, version: 0 };\r\n  }\r\n\r\n  get user(): IUser {\r\n    return this._user;\r\n  }\r\n\r\n  private addItem(kind: IDataKind, key: string, item: IStoreItem) {\r\n    let items = this.store[kind.namespace];\r\n    if (!items) {\r\n      items = {};\r\n      this.store[kind.namespace] = items;\r\n    }\r\n    if (Object.hasOwnProperty.call(items, key)) {\r\n      const old = items[key];\r\n      if (!old || old.version < item.version) {\r\n        items[key] = item;\r\n      }\r\n    } else {\r\n      items[key] = item;\r\n    }\r\n\r\n    if (item.version > this.store.version) {\r\n      this.store.version = item.version;\r\n    }\r\n\r\n    this.allStores[`${StoreStorageKey}-${this._user.keyId}`] = {...this.store};\r\n  }\r\n\r\n  get(kind: IDataKind, key: string): IStoreItem | null {\r\n    const items = this.store[kind.namespace];\r\n    if (items) {\r\n      if (Object.prototype.hasOwnProperty.call(items, key)) {\r\n        const item = items[key];\r\n        if (item) {\r\n          return item;\r\n        }\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  all(kind: IDataKind): [IStoreKindData, number] {\r\n    const result: IStoreKindData = {};\r\n    const items = this.store[kind.namespace] ?? {};\r\n    Object.entries(items).forEach(([key, item]) => {\r\n      if (item) {\r\n        result[key] = <IStoreItem>item;\r\n      }\r\n    });\r\n\r\n    return [result, this.store.version];\r\n  }\r\n\r\n  init(allData: IStoreDataStorage, callback: () => void): void {\r\n    this.store = allData as IStoreDataStorage;\r\n\r\n    this.store.version = 0;\r\n    Object.keys(allData).map(namespace => {\r\n      Object.entries(allData[namespace]).forEach(([_, item]) => {\r\n        const ele = item as IStoreItem;\r\n        if (ele.version > this.store.version) {\r\n          this.store.version = ele.version;\r\n        }\r\n      })\r\n    });\r\n\r\n    this.allStores[`${StoreStorageKey}-${this._user.keyId}`] = {...this.store};\r\n    this.initCalled = true;\r\n    callback?.();\r\n  }\r\n\r\n  upsert(kind: IDataKind, data: IKeyedStoreItem, callback: () => void): void {\r\n    this.addItem(kind, data.key, data);\r\n    callback?.();\r\n  }\r\n\r\n  initialized(): boolean {\r\n    return this.initCalled;\r\n  }\r\n\r\n  /* eslint-disable class-methods-use-this */\r\n  close(): void {\r\n    // For the memory store this is a no-op.\r\n  }\r\n\r\n  getDescription(): string {\r\n    return 'in-memory-store';\r\n  }\r\n\r\n  get version(): number {\r\n    return this.store.version;\r\n  }\r\n}","export * from './DataKinds';\r\nexport * from './IDataSourceUpdates';\r\nexport * from './InMemoryStore';\r\nexport * from './serialization';\r\nexport * from './store';","import { IFlag } from \"../evaluation/data/IFlag\";\r\nimport DataKinds from \"./DataKinds\";\r\nimport { IVersionedData } from \"../IVersionedData\";\r\nimport { IDataKind } from \"../IDataKind\";\r\n\r\nexport interface Flags {\r\n  flags: { [name: string]: IFlag };\r\n}\r\n\r\ntype VersionedFlag = IVersionedData & IFlag;\r\n\r\nexport interface IPatchData {\r\n  data: VersionedFlag;\r\n  kind: IDataKind;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function deserializeAll(flags: IFlag[]): Flags {\r\n  const result = {\r\n    [DataKinds.Flags.namespace]: {}\r\n  };\r\n\r\n  if (flags?.length) {\r\n    result[DataKinds.Flags.namespace] = flags.reduce((acc: any, cur: any) => {\r\n      acc[cur.id] = {...cur, version: cur.timestamp || 0, key: cur.id, variations: cur.variationOptions};\r\n      return acc;\r\n    }, {});\r\n  }\r\n\r\n  return result as any as Flags;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function deserializePatch(flags: IFlag[]): IPatchData[] {\r\n  const result = [\r\n    ...flags?.map(item => ({\r\n      data: {\r\n        ...item,\r\n        version:item.timestamp,\r\n        key: item.id,\r\n        variations: item.variationOptions\r\n      },\r\n      kind: DataKinds.Flags\r\n    })) || []\r\n  ];\r\n\r\n  return result as any as IPatchData[];\r\n}\r\n","export const StoreStorageKey = 'fb-datastore';\r\n\r\nexport const CurrentUserStorageKey = 'fb-user';\r\n\r\n/**\r\n * Represents an item which can be stored in the feature store.\r\n */\r\nexport interface IStoreItem {\r\n  version: number;\r\n\r\n  // The actual data associated with the item.\r\n  [attribute: string]: any;\r\n}\r\n\r\n/**\r\n * When upserting an item it must contain a key.\r\n */\r\nexport interface IKeyedStoreItem extends IStoreItem {\r\n  key: string;\r\n}\r\n\r\n/**\r\n * Represents the storage for a single kind of data. e.g. 'flag' or 'segment'.\r\n */\r\nexport interface IStoreKindData {\r\n  [key: string]: IStoreItem;\r\n}\r\n\r\n/**\r\n * Represents the storage for the full data store.\r\n */\r\nexport interface IStoreDataStorage {\r\n  flags: IStoreKindData;\r\n  version: number;\r\n\r\n  // This attribute is to ingore the type check error\r\n  [attribute: string]: any;\r\n}","import { IEventEmitter } from \"./IEventEmitter\";\r\n\r\nexport type EventableConstructor<T = {}> = new (...args: any[]) => T;\r\nexport type Eventable = EventableConstructor<{ emitter: IEventEmitter }>;\r\n\r\n/**\r\n * Adds the implementation of an event emitter to something that contains\r\n * a field of `emitter` with type `EventEmitter`.\r\n * @param Base The class to derive the mixin from.\r\n * @returns A class extending the base with an event emitter.\r\n */\r\nexport function Emits<TBase extends Eventable>(Base: TBase) {\r\n  return class WithEvents extends Base implements IEventEmitter {\r\n    on(eventName: string | symbol, listener: (...args: any[]) => void, context?: any): this {\r\n      this.emitter.on(eventName, listener, context);\r\n      return this;\r\n    }\r\n\r\n    addListener(eventName: string | symbol, listener: (...args: any[]) => void, context?: any): this {\r\n      this.emitter.addListener(eventName, listener, context);\r\n      return this;\r\n    }\r\n\r\n    once(eventName: string | symbol, listener: (...args: any[]) => void, context?: any): this {\r\n      this.emitter.once(eventName, listener, context);\r\n      return this;\r\n    }\r\n\r\n    removeListener(eventName: string | symbol, listener: (...args: any[]) => void, context?: any): this {\r\n      this.emitter.removeListener(eventName, listener, context);\r\n      return this;\r\n    }\r\n\r\n    off(eventName: string | symbol, listener: (...args: any) => void, context?: any): this {\r\n      this.emitter.off(eventName, listener, context);\r\n      return this;\r\n    }\r\n\r\n    removeAllListeners(event?: string | symbol): this {\r\n      this.emitter.removeAllListeners(event);\r\n      return this;\r\n    }\r\n\r\n    listeners(eventName: string | symbol): Function[] {\r\n      return this.emitter.listeners(eventName);\r\n    }\r\n\r\n    emit(eventName: string | symbol, ...args: any[]): this  {\r\n      this.emitter.emit(eventName, args);\r\n      return this;\r\n    }\r\n\r\n    listenerCount(eventName: string | symbol): number {\r\n      return this.emitter.listenerCount(eventName);\r\n    }\r\n\r\n    prependListener(eventName: string | symbol, listener: (...args: any[]) => void, context?: any): this {\r\n      this.emitter.prependListener(eventName, listener, context);\r\n      return this;\r\n    }\r\n\r\n    prependOnceListener(eventName: string | symbol, listener: (...args: any[]) => void, context?: any): this {\r\n      this.emitter.prependOnceListener(eventName, listener, context);\r\n      return this;\r\n    }\r\n\r\n    eventNames(): (string | symbol)[] {\r\n      return this.emitter.eventNames();\r\n    }\r\n\r\n    maybeReportError (error: any): this {\r\n      this.emitter.maybeReportError(error);\r\n      return this;\r\n    }\r\n  };\r\n}","import { ILogger } from \"../logging/ILogger\";\r\nimport { IEventEmitter } from \"./IEventEmitter\";\r\n\r\ninterface Events {\r\n  [key: string | symbol]: {\r\n    handler: (...args: any[]) => void;\r\n    context: any;\r\n  }[];\r\n}\r\n\r\nexport class EventEmitter implements IEventEmitter {\r\n  private events: Events = {};\r\n\r\n  constructor(private logger?: ILogger) {}\r\n\r\n  private listeningTo (event: string) {\r\n    return !!this.events[event];\r\n  }\r\n\r\n  on (event: string | symbol, handler: (...args: any[]) => void, context?: any): this {\r\n    this.events[event] = this.events[event] || [];\r\n    this.events[event] = this.events[event].concat({\r\n      handler: handler,\r\n      context: context,\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  addListener (event: string | symbol, handler: (...args: any[]) => void, context?: any): this {\r\n    return this.on(event, handler, context);\r\n  }\r\n\r\n  once (event: string | symbol, handler: (...args: any[]) => void, context?: any): this {\r\n    const onceHandler = (...args: any[]) => {\r\n      this.off(event, onceHandler, context);\r\n      handler.apply(context, args);\r\n    };\r\n    return this.on(event, onceHandler, context);\r\n  }\r\n\r\n  off (event: string | symbol, handler: (...args: any[]) => void, context?: any): this {\r\n    if (!this.events[event]) {\r\n      return this;\r\n    }\r\n    for (let i = 0; i < this.events[event].length; i++) {\r\n      if (this.events[event][i].handler === handler && this.events[event][i].context === context) {\r\n        this.events[event] = this.events[event].slice(0, i).concat(this.events[event].slice(i + 1));\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  removeListener (event: string | symbol, handler: (...args: any[]) => void, context?: any): this {\r\n    return this.off(event, handler, context);\r\n  }\r\n\r\n  removeAllListeners (event?: string | symbol): this {\r\n    if (event) {\r\n      delete this.events[event];\r\n    } else {\r\n      this.events = {};\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  listeners (event: string | symbol): Function[] {\r\n    return this.events[event] ? this.events[event].map((event) => event.handler) : [];\r\n  }\r\n\r\n  emit (event: string | symbol, ...args: any[]): this {\r\n    if (!this.events[event]) {\r\n      return this;\r\n    }\r\n    // Copy the list of handlers before iterating, in case any handler adds or removes another handler.\r\n    // Any such changes should not affect what we do here-- we want to notify every handler that existed\r\n    // at the moment that the event was fired.\r\n    const copiedHandlers = [...this.events[event]];\r\n    for (let i = 0; i < copiedHandlers.length; i++) {\r\n      copiedHandlers[i].handler.apply(copiedHandlers[i].context, Array.prototype.slice.call(arguments, 1));\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  listenerCount (event: string | symbol): number {\r\n    return this.events[event] ? this.events[event].length : 0;\r\n  }\r\n\r\n  prependListener (event: string | symbol, handler: (...args: any[]) => void, context?: any): this {\r\n    this.events[event] = this.events[event] || [];\r\n    this.events[event] = [\r\n      {\r\n        handler: handler,\r\n        context: context,\r\n      },\r\n      ...this.events[event]\r\n    ];\r\n\r\n    return this;\r\n  }\r\n\r\n  prependOnceListener (event: string | symbol, handler: (...args: any[]) => void, context?: any): this {\r\n    const onceHandler = (...args: any[]) => {\r\n      this.off(event, onceHandler, context);\r\n      handler.apply(context, args);\r\n    };\r\n    return this.prependListener(event, onceHandler, context);\r\n  }\r\n\r\n  eventNames (): (string | symbol)[] {\r\n    return Object.keys(this.events);\r\n  }\r\n\r\n  maybeReportError (error: any): this {\r\n    if (!error) {\r\n      return this;\r\n    }\r\n    if (this.listeningTo('error')) {\r\n      this.emit('error', error);\r\n    } else {\r\n      this.logger?.error(error);\r\n    }\r\n\r\n    return this;\r\n  }\r\n}","import { isNullOrUndefined } from \"./isNullOrUndefined\";\r\n\r\nexport class Regex {\r\n  private static patternWithFlags = /\\/(.*)\\/([a-z]*)/i;\r\n  private static whiteSpaceRegex = /\\s/g;\r\n\r\n  static fromString(patternString: string): RegExp {\r\n    let flags = '';\r\n    const match = patternString.match(Regex.patternWithFlags);\r\n\r\n    if (match) {\r\n      patternString = match[1]; // Update the pattern string\r\n      flags = match[2]; // Update the flags\r\n    }\r\n\r\n    return new RegExp(patternString, flags);\r\n  }\r\n\r\n  static isNullOrWhiteSpace(str: string) {\r\n    return isNullOrUndefined(str) || !str.replace(Regex.whiteSpaceRegex, '').length;\r\n  }\r\n}","import { Regex } from \"./Regex\";\r\n\r\nexport interface IConvertResult<TValue> {\r\n  isSucceeded: boolean,\r\n  value?: TValue\r\n}\r\n\r\nexport class ValueConverters {\r\n  static bool(value: string): IConvertResult<boolean> {\r\n    if (value?.toUpperCase() === 'TRUE') {\r\n      return ValueConverters.success<boolean>(true);\r\n    }\r\n\r\n    if (value?.toUpperCase() === 'FALSE') {\r\n      return ValueConverters.success<boolean>(false);\r\n    }\r\n\r\n    return ValueConverters.error<boolean>();\r\n  }\r\n\r\n  static number(value: string): IConvertResult<number> {\r\n    const num = Number(value);\r\n\r\n    if (Number.isNaN(num)) {\r\n      return ValueConverters.error<number>();\r\n    }\r\n\r\n    return ValueConverters.success<number>(num);\r\n  }\r\n\r\n  static string(value: string): IConvertResult<string> {\r\n    return ValueConverters.success<string>(value);\r\n  }\r\n\r\n  static json(value: string): IConvertResult<unknown> {\r\n    try {\r\n      const val = JSON.parse(value);\r\n      return ValueConverters.success<unknown>(val);\r\n    } catch (err) {\r\n      return ValueConverters.error<unknown>();\r\n    }\r\n  }\r\n\r\n  private static success<TValue>(value: TValue): IConvertResult<TValue> {\r\n    return {\r\n      isSucceeded: true,\r\n      value: value\r\n    }\r\n  }\r\n\r\n  private static error<TValue>(): IConvertResult<TValue> {\r\n    return {\r\n      isSucceeded: false\r\n    }\r\n  }\r\n}","// This function is designed to remove any trailing forward slashes at the end of the provided URI string\r\nexport function canonicalizeUri(uri: string): string {\r\n  return uri.replace(/\\/+$/, '');\r\n}","import { IInfo } from \"../platform/IInfo\";\r\n\r\nexport type Headers = {\r\n  Authorization: string;\r\n  'User-Agent': string;\r\n  'Content-Type': string;\r\n};\r\n\r\nexport function defaultHeaders(\r\n  sdkKey: string,\r\n  info: IInfo\r\n): Headers {\r\n  const {userAgentBase, version} = info.sdkData();\r\n\r\n  const headers: Headers = {\r\n    'Content-Type': 'application/json',\r\n    'User-Agent': `${ userAgentBase ?? info.appType }/${ version }`,\r\n    'Authorization': sdkKey\r\n  };\r\n\r\n  return headers;\r\n}\r\n\r\nexport function httpErrorMessage(\r\n  err: {\r\n    status: number;\r\n    message: string;\r\n  },\r\n  context: string,\r\n  retryMessage?: string,\r\n): string {\r\n  let desc;\r\n  if (err.status) {\r\n    desc = `error ${ err.status }${ err.status === 401 ? ' (invalid SDK key)' : '' }`;\r\n  } else {\r\n    desc = `I/O error (${ err.message || err })`;\r\n  }\r\n  const action = retryMessage ?? 'giving up permanently';\r\n  return `Received ${ desc } for ${ context } - ${ action }`;\r\n}\r\n","export * from './isNullOrUndefined';\r\nexport * from './sleep';\r\nexport * from './ValueConverters';\r\nexport * from './VoidFunction';","export function isNullOrUndefined(val: any) {\r\n  return val === null || val === undefined;\r\n}","import { IUser } from \"../options/IUser\";\r\n\r\nexport function serializeUser(user: IUser | undefined): string {\r\n  if (!user) {\r\n    return '';\r\n  }\r\n\r\n  const builtInProperties = `${user.keyId},${user.name}`;\r\n\r\n  const customizedProperties = user.customizedProperties\r\n    ?.sort((a, b) => {\r\n      const nameA = a.name.toLowerCase();\r\n      const nameB = b.name.toLowerCase();\r\n      if (nameA < nameB) {\r\n        return -1;\r\n      }\r\n\r\n      if (nameA > nameB) {\r\n        return 1;\r\n      }\r\n\r\n      return 0;\r\n    })\r\n    .map(p => `${p.name}:${p.value}`)\r\n    .join(',');\r\n\r\n  return `${builtInProperties},${customizedProperties}`;\r\n}","const sleep = async (delayMillis: number = 1000) =>\r\n  new Promise((resolve) => {\r\n    setTimeout(resolve, delayMillis);\r\n  });\r\n\r\nexport default sleep;","export const version = \"3.0.0\"; export const name = \"@featbit/js-client-sdk\";\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(9872);\n"],"names":["root","factory","exports","module","define","amd","a","i","this","validations","startWaitTime","TypeValidators","Number","sdkKey","String","pollingUri","streamingUri","eventsUri","webSocketPingInterval","logger","Object","store","ObjectOrFactory","dataSynchronizer","flushInterval","maxEventsInQueue","pollingInterval","offline","Boolean","dataSyncMode","bootstrap","Bootstrap","user","User","defaultValues","DataSyncModeEnum","STREAMING","sendEvents","options","undefined","constructor","bootstrapProvider","NullBootstrapProvider","errors","validatedOptions","keys","forEach","optionName","optionValue","validator","is","getType","push","wrongOptionTypeBoolean","NumberWithMinimum","min","optionBelowMinimum","UserValidator","messages","wrongOptionType","warn","unknownOption","validateTypesAndNames","error","streamingUriMissing","isNullOrUndefined","EmptyString","pollingUriMissing","eventsUriMissing","partialEndpoint","POLLING","validateEndpoints","canonicalizeUri","length","JsonBootstrapProvider","_","info","Function","dataSynchronizerFactory","storeFactory","Context","valid","message","fromUser","contextForError","keyId","name","trim","context","_user","value","property","customizedProperties","find","x","_options","build","mode","flags","ClientState","platform","callbacks","state","Initializing","onError","onFailed","onReady","onUpdate","hasEventListeners","config","Error","init","clientContext","identify","dataSourceUpdates","evaluator","populate","eventProcessor","NullEventProcessor","NullDataSynchronizer","initSuccess","DefaultEventProcessor","listeners","createStreamListeners","put","patch","webSocket","version","requests","e","dataSourceErrorHandler","start","setTimeout","initialized","msg","Failed","rejectionReason","initReject","Initialized","waitForInitialization","initializedPromise","Promise","resolve","reject","initResolve","boolVariation","key","defaultValue","evaluateCore","ValueConverters","bool","boolVariationDetail","jsonVariation","json","jsonVariationDetail","numberVariation","number","numberVariationDetail","stringVariation","string","stringVariationDetail","variation","variationDetail","getAllVariations","ClientError","all","Flags","result","map","flagKey","evalResult","evaluate","kind","reason","close","track","eventName","metricValue","metricEvent","MetricEvent","appType","record","flush","callback","err","typeConverter","ReasonKinds","FlagNotFound","toEvalEvent","isSucceeded","WrongType","code","flag","variationOptions","id","data","deserializeAll","dataSet","userKeyId","MinInt","onChange","allData","checkForChanges","doInit","oldData","then","updatedKeys","flatMap","namespace","oldDataForKind","newDataForKind","mergedData","filter","isUpdated","upsert","doUpsert","oldItem","get","newData","itemsByNamespace","set","remove","items","removeAll","enumerate","entries","values","mergeFrom","other","bind","createPutListener","onPutCompleteHandler","deserializeData","processJson","initData","debug","createPatchListener","onPatchCompleteHandler","deserializePatch","item","onCompleteHandlers","Map","stop","requestor","getStoreTimestamp","errorHandler","stopped","poll","startTime","Date","now","requestData","body","elapsed","sleepFor","Math","max","status","isHttpRecoverable","httpErrorMessage","PollingError","featureFlags","processStreamResponse","JSON","parse","messageType","eventType","StreamResponseEventType","full","timeoutHandle","clearTimeout","headers","defaultHeaders","uri","request","requestUrl","res","fetch","text","timestamp","payload","cb","method","stringify","StreamingError","socket","pingInterval","addListener","event","logConnectionStarted","connect","connectionAttemptStartTime","alphabet","encodeNumber","param","s","slice","split","n","join","replace","timestampCode","toString","floor","random","super","UnexpectedResponseError","EvalResult","flagNotFound","matched","val","Match","targetedVariation","variations","v","EvalEvent","sendToExperiment","VariationDataType","OperatorTypes","Operator","operation","func","isMatch","conditionValue","numericOperator","desiredComparisonResult","otherDesiredComparisonResult","param1","param2","param1FloatValue","parseFloat","param2FloatValue","isNaN","sign","op","All","o","LessThan","LessEqualThan","BiggerThan","BiggerEqualThan","Equal","NotEqual","Contains","includes","NotContains","NotContain","StartsWith","startsWith","EndsWith","endsWith","MatchRegex","pattern","Regex","fromString","test","NotMatchRegex","IsOneOf","NotOneOf","IsTrue","toUpperCase","IsFalse","closed","eventQueue","DefaultEventQueue","eventDispatcher","EventDispatcher","flushLoop","flushEvent","FlushEvent","waitForCompletion","shutdown","ShutdownEvent","addEvent","complete","capacity","events","clear","shift","eventsSnapshot","isEmpty","send","retry","DeliveryStatus","Succeeded","FailedAndMustShutDown","serialize","toPayload","queue","maxEventPerRequest","buffer","sender","DefaultEventSender","serializer","DefaultEventSerializer","dispatchLoop","running","PayloadEvent","addEventToBuffer","triggerFlush","snapshot","flushEvents","total","getUniqueEvents","uniqueEvents","hashes","hash","AsyncEvent","getTime","isCompletedPromise","resolveFn","userPayload","metrics","route","numericValue","type","hasObject","m","featureFlagKey","LogPriority","none","LevelNames","BasicLogger","logLevel","level","destination","formatter","tryFormat","args","tryWrite","console","log","prefix","loggerRequirements","fallback","tryStringify","prototype","hasOwnProperty","call","TypeError","indexOf","escapes","d","toNumber","parseInt","toInt","f","toFloat","j","O","c","formatString","out","char","charAt","nextChar","configuration","expectedType","actualType","mandatory","invalidOptionValue","missingKeyInBootstrapValue","_keyId","_name","_custom","custom","propertyName","FactoryOrInstance","factoryOrInstance","Array","isArray","typeOfFactory","Type","typeName","example","typeOf","u","TypeArray","every","StringMatchingRegex","expression","match","NullableBoolean","DATE_REGEX","DateValidator","KindValidator","createTypeArray","numberWithMin","stringMatchingRegex","StringArray","Kind","platformData","os","additional","sdkData","userAgentBase","url","socketConnectionIntervals","Emits","retryCounter","_config","emitter","EventEmitter","doDataSync","that","generateConnectionToken","ws","WebSocket","addEventListener","sendPingMessage","reconnect","emit","readyState","OPEN","waitTime","FbClient","FbClientCore","fallbackLogger","listenerCount","eventNames","some","initCalled","localStorage","setItem","CurrentUserStorageKey","serializeUser","loadStoreFromStorage","addItem","old","dumpStoreToStorage","ele","getDescription","storageKey","StoreStorageKey","dataStoreStr","getItem","DataKinds","allStores","reduce","acc","cur","Base","on","listener","once","removeListener","off","removeAllListeners","prependListener","prependOnceListener","maybeReportError","listeningTo","handler","concat","onceHandler","apply","copiedHandlers","arguments","patternString","patternWithFlags","RegExp","isNullOrWhiteSpace","str","whiteSpaceRegex","success","num","retryMessage","desc","sort","b","nameA","toLowerCase","nameB","p","delayMillis","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}